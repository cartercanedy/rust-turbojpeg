/* automatically generated by rust-bindgen 0.57.0 */

pub const TJ_NUMINIT: u32 = 3;
pub const TJ_NUMSAMP: u32 = 7;
pub const TJ_NUMPF: u32 = 12;
pub const TJ_NUMCS: u32 = 5;
pub const TJ_NUMERR: u32 = 2;
pub const TJ_NUMXOP: u32 = 8;
pub const TJXOPT_PERFECT: u32 = 1;
pub const TJXOPT_TRIM: u32 = 2;
pub const TJXOPT_CROP: u32 = 4;
pub const TJXOPT_GRAY: u32 = 8;
pub const TJXOPT_NOOUTPUT: u32 = 16;
pub const TJXOPT_PROGRESSIVE: u32 = 32;
pub const TJXOPT_COPYNONE: u32 = 64;
pub const TJXOPT_ARITHMETIC: u32 = 128;
pub const TJXOPT_OPTIMIZE: u32 = 256;
pub const NUMSUBOPT: u32 = 7;
pub const TJ_BGR: u32 = 1;
pub const TJ_ALPHAFIRST: u32 = 64;
pub const TJ_YUV: u32 = 512;
pub const TJFLAG_BOTTOMUP: u32 = 2;
pub const TJFLAG_FORCEMMX: u32 = 8;
pub const TJFLAG_FORCESSE: u32 = 16;
pub const TJFLAG_FORCESSE2: u32 = 32;
pub const TJFLAG_FORCESSE3: u32 = 128;
pub const TJFLAG_FASTUPSAMPLE: u32 = 256;
pub const TJFLAG_NOREALLOC: u32 = 1024;
pub const TJFLAG_FASTDCT: u32 = 2048;
pub const TJFLAG_ACCURATEDCT: u32 = 4096;
pub const TJFLAG_STOPONWARNING: u32 = 8192;
pub const TJFLAG_PROGRESSIVE: u32 = 16384;
pub const TJFLAG_LIMITSCANS: u32 = 32768;
pub type size_t = libc::c_ulong;
pub type wchar_t = libc::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: libc::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::core::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::core::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
#[doc = " Initialize the TurboJPEG instance for compression."]
pub const TJINIT_TJINIT_COMPRESS: TJINIT = 0;
#[doc = " Initialize the TurboJPEG instance for decompression."]
pub const TJINIT_TJINIT_DECOMPRESS: TJINIT = 1;
#[doc = " Initialize the TurboJPEG instance for lossless transformation (both"]
#[doc = " compression and decompression.)"]
pub const TJINIT_TJINIT_TRANSFORM: TJINIT = 2;
#[doc = " Initialization options"]
pub type TJINIT = libc::c_uint;
#[doc = " 4:4:4 chrominance subsampling (no chrominance subsampling)"]
#[doc = ""]
#[doc = " The JPEG or YUV image will contain one chrominance component for every"]
#[doc = " pixel in the source image."]
pub const TJSAMP_TJSAMP_444: TJSAMP = 0;
#[doc = " 4:2:2 chrominance subsampling"]
#[doc = ""]
#[doc = " The JPEG or YUV image will contain one chrominance component for every 2x1"]
#[doc = " block of pixels in the source image."]
pub const TJSAMP_TJSAMP_422: TJSAMP = 1;
#[doc = " 4:2:0 chrominance subsampling"]
#[doc = ""]
#[doc = " The JPEG or YUV image will contain one chrominance component for every 2x2"]
#[doc = " block of pixels in the source image."]
pub const TJSAMP_TJSAMP_420: TJSAMP = 2;
#[doc = " Grayscale"]
#[doc = ""]
#[doc = " The JPEG or YUV image will contain no chrominance components."]
pub const TJSAMP_TJSAMP_GRAY: TJSAMP = 3;
#[doc = " 4:4:0 chrominance subsampling"]
#[doc = ""]
#[doc = " The JPEG or YUV image will contain one chrominance component for every 1x2"]
#[doc = " block of pixels in the source image."]
#[doc = ""]
#[doc = " @note 4:4:0 subsampling is not fully accelerated in libjpeg-turbo."]
pub const TJSAMP_TJSAMP_440: TJSAMP = 4;
#[doc = " 4:1:1 chrominance subsampling"]
#[doc = ""]
#[doc = " The JPEG or YUV image will contain one chrominance component for every 4x1"]
#[doc = " block of pixels in the source image.  All else being equal, a JPEG image"]
#[doc = " with 4:1:1 subsampling is almost exactly the same size as a JPEG image"]
#[doc = " with 4:2:0 subsampling, and in the aggregate, both subsampling methods"]
#[doc = " produce approximately the same perceptual quality.  However, 4:1:1 is"]
#[doc = " better able to reproduce sharp horizontal features."]
#[doc = ""]
#[doc = " @note 4:1:1 subsampling is not fully accelerated in libjpeg-turbo."]
pub const TJSAMP_TJSAMP_411: TJSAMP = 5;
#[doc = " 4:4:1 chrominance subsampling"]
#[doc = ""]
#[doc = " The JPEG or YUV image will contain one chrominance component for every 1x4"]
#[doc = " block of pixels in the source image.  All else being equal, a JPEG image"]
#[doc = " with 4:4:1 subsampling is almost exactly the same size as a JPEG image"]
#[doc = " with 4:2:0 subsampling, and in the aggregate, both subsampling methods"]
#[doc = " produce approximately the same perceptual quality.  However, 4:4:1 is"]
#[doc = " better able to reproduce sharp vertical features."]
#[doc = ""]
#[doc = " @note 4:4:1 subsampling is not fully accelerated in libjpeg-turbo."]
pub const TJSAMP_TJSAMP_441: TJSAMP = 6;
#[doc = " Unknown subsampling"]
#[doc = ""]
#[doc = " The JPEG image uses an unusual type of chrominance subsampling.  Such"]
#[doc = " images can be decompressed into packed-pixel images, but they cannot be"]
#[doc = " - decompressed into planar YUV images,"]
#[doc = " - losslessly transformed if #TJXOPT_CROP is specified and #TJXOPT_GRAY is"]
#[doc = " not specified, or"]
#[doc = " - partially decompressed using a cropping region."]
pub const TJSAMP_TJSAMP_UNKNOWN: TJSAMP = -1;
#[doc = " Chrominance subsampling options"]
#[doc = ""]
#[doc = " When pixels are converted from RGB to YCbCr (see #TJCS_YCbCr) or from CMYK"]
#[doc = " to YCCK (see #TJCS_YCCK) as part of the JPEG compression process, some of"]
#[doc = " the Cb and Cr (chrominance) components can be discarded or averaged together"]
#[doc = " to produce a smaller image with little perceptible loss of image quality."]
#[doc = " (The human eye is more sensitive to small changes in brightness than to"]
#[doc = " small changes in color.)  This is called \"chrominance subsampling\"."]
pub type TJSAMP = libc::c_int;
extern "C" {
    pub static tjMCUWidth: [libc::c_int; 7usize];
}
extern "C" {
    pub static tjMCUHeight: [libc::c_int; 7usize];
}
#[doc = " RGB pixel format"]
#[doc = ""]
#[doc = " The red, green, and blue components in the image are stored in 3-sample"]
#[doc = " pixels in the order R, G, B from lowest to highest memory address within"]
#[doc = " each pixel."]
pub const TJPF_TJPF_RGB: TJPF = 0;
#[doc = " BGR pixel format"]
#[doc = ""]
#[doc = " The red, green, and blue components in the image are stored in 3-sample"]
#[doc = " pixels in the order B, G, R from lowest to highest memory address within"]
#[doc = " each pixel."]
pub const TJPF_TJPF_BGR: TJPF = 1;
#[doc = " RGBX pixel format"]
#[doc = ""]
#[doc = " The red, green, and blue components in the image are stored in 4-sample"]
#[doc = " pixels in the order R, G, B from lowest to highest memory address within"]
#[doc = " each pixel.  The X component is ignored when compressing/encoding and"]
#[doc = " undefined when decompressing/decoding."]
pub const TJPF_TJPF_RGBX: TJPF = 2;
#[doc = " BGRX pixel format"]
#[doc = ""]
#[doc = " The red, green, and blue components in the image are stored in 4-sample"]
#[doc = " pixels in the order B, G, R from lowest to highest memory address within"]
#[doc = " each pixel.  The X component is ignored when compressing/encoding and"]
#[doc = " undefined when decompressing/decoding."]
pub const TJPF_TJPF_BGRX: TJPF = 3;
#[doc = " XBGR pixel format"]
#[doc = ""]
#[doc = " The red, green, and blue components in the image are stored in 4-sample"]
#[doc = " pixels in the order R, G, B from highest to lowest memory address within"]
#[doc = " each pixel.  The X component is ignored when compressing/encoding and"]
#[doc = " undefined when decompressing/decoding."]
pub const TJPF_TJPF_XBGR: TJPF = 4;
#[doc = " XRGB pixel format"]
#[doc = ""]
#[doc = " The red, green, and blue components in the image are stored in 4-sample"]
#[doc = " pixels in the order B, G, R from highest to lowest memory address within"]
#[doc = " each pixel.  The X component is ignored when compressing/encoding and"]
#[doc = " undefined when decompressing/decoding."]
pub const TJPF_TJPF_XRGB: TJPF = 5;
#[doc = " Grayscale pixel format"]
#[doc = ""]
#[doc = " Each 1-sample pixel represents a luminance (brightness) level from 0 to"]
#[doc = " the maximum sample value (which is, for instance, 255 for 8-bit samples or"]
#[doc = " 4095 for 12-bit samples or 65535 for 16-bit samples.)"]
pub const TJPF_TJPF_GRAY: TJPF = 6;
#[doc = " RGBA pixel format"]
#[doc = ""]
#[doc = " This is the same as @ref TJPF_RGBX, except that when"]
#[doc = " decompressing/decoding, the X component is guaranteed to be equal to the"]
#[doc = " maximum sample value, which can be interpreted as an opaque alpha channel."]
pub const TJPF_TJPF_RGBA: TJPF = 7;
#[doc = " BGRA pixel format"]
#[doc = ""]
#[doc = " This is the same as @ref TJPF_BGRX, except that when"]
#[doc = " decompressing/decoding, the X component is guaranteed to be equal to the"]
#[doc = " maximum sample value, which can be interpreted as an opaque alpha channel."]
pub const TJPF_TJPF_BGRA: TJPF = 8;
#[doc = " ABGR pixel format"]
#[doc = ""]
#[doc = " This is the same as @ref TJPF_XBGR, except that when"]
#[doc = " decompressing/decoding, the X component is guaranteed to be equal to the"]
#[doc = " maximum sample value, which can be interpreted as an opaque alpha channel."]
pub const TJPF_TJPF_ABGR: TJPF = 9;
#[doc = " ARGB pixel format"]
#[doc = ""]
#[doc = " This is the same as @ref TJPF_XRGB, except that when"]
#[doc = " decompressing/decoding, the X component is guaranteed to be equal to the"]
#[doc = " maximum sample value, which can be interpreted as an opaque alpha channel."]
pub const TJPF_TJPF_ARGB: TJPF = 10;
#[doc = " CMYK pixel format"]
#[doc = ""]
#[doc = " Unlike RGB, which is an additive color model used primarily for display,"]
#[doc = " CMYK (Cyan/Magenta/Yellow/Key) is a subtractive color model used primarily"]
#[doc = " for printing.  In the CMYK color model, the value of each color component"]
#[doc = " typically corresponds to an amount of cyan, magenta, yellow, or black ink"]
#[doc = " that is applied to a white background.  In order to convert between CMYK"]
#[doc = " and RGB, it is necessary to use a color management system (CMS.)  A CMS"]
#[doc = " will attempt to map colors within the printer's gamut to perceptually"]
#[doc = " similar colors in the display's gamut and vice versa, but the mapping is"]
#[doc = " typically not 1:1 or reversible, nor can it be defined with a simple"]
#[doc = " formula.  Thus, such a conversion is out of scope for a codec library."]
#[doc = " However, the TurboJPEG API allows for compressing packed-pixel CMYK images"]
#[doc = " into YCCK JPEG images (see #TJCS_YCCK) and decompressing YCCK JPEG images"]
#[doc = " into packed-pixel CMYK images."]
pub const TJPF_TJPF_CMYK: TJPF = 11;
#[doc = " Unknown pixel format"]
#[doc = ""]
#[doc = " Currently this is only used by #tj3LoadImage8(), #tj3LoadImage12(), and"]
#[doc = " #tj3LoadImage16()."]
pub const TJPF_TJPF_UNKNOWN: TJPF = -1;
#[doc = " Pixel formats"]
pub type TJPF = libc::c_int;
extern "C" {
    pub static tjRedOffset: [libc::c_int; 12usize];
}
extern "C" {
    pub static tjGreenOffset: [libc::c_int; 12usize];
}
extern "C" {
    pub static tjBlueOffset: [libc::c_int; 12usize];
}
extern "C" {
    pub static tjAlphaOffset: [libc::c_int; 12usize];
}
extern "C" {
    pub static tjPixelSize: [libc::c_int; 12usize];
}
#[doc = " RGB colorspace"]
#[doc = ""]
#[doc = " When generating the JPEG image, the R, G, and B components in the source"]
#[doc = " image are reordered into image planes, but no colorspace conversion or"]
#[doc = " subsampling is performed.  RGB JPEG images can be generated from and"]
#[doc = " decompressed to packed-pixel images with any of the extended RGB or"]
#[doc = " grayscale pixel formats, but they cannot be generated from or"]
#[doc = " decompressed to planar YUV images."]
pub const TJCS_TJCS_RGB: TJCS = 0;
#[doc = " YCbCr colorspace"]
#[doc = ""]
#[doc = " YCbCr is not an absolute colorspace but rather a mathematical"]
#[doc = " transformation of RGB designed solely for storage and transmission.  YCbCr"]
#[doc = " images must be converted to RGB before they can be displayed.  In the"]
#[doc = " YCbCr colorspace, the Y (luminance) component represents the black & white"]
#[doc = " portion of the original image, and the Cb and Cr (chrominance) components"]
#[doc = " represent the color portion of the original image.  Historically, the"]
#[doc = " analog equivalent of this transformation allowed the same signal to be"]
#[doc = " displayed to both black & white and color televisions, but JPEG images use"]
#[doc = " YCbCr primarily because it allows the color data to be optionally"]
#[doc = " subsampled in order to reduce network and disk usage.  YCbCr is the most"]
#[doc = " common JPEG colorspace, and YCbCr JPEG images can be generated from and"]
#[doc = " decompressed to packed-pixel images with any of the extended RGB or"]
#[doc = " grayscale pixel formats.  YCbCr JPEG images can also be generated from"]
#[doc = " and decompressed to planar YUV images."]
pub const TJCS_TJCS_YCbCr: TJCS = 1;
#[doc = " Grayscale colorspace"]
#[doc = ""]
#[doc = " The JPEG image retains only the luminance data (Y component), and any"]
#[doc = " color data from the source image is discarded.  Grayscale JPEG images can"]
#[doc = " be generated from and decompressed to packed-pixel images with any of the"]
#[doc = " extended RGB or grayscale pixel formats, or they can be generated from"]
#[doc = " and decompressed to planar YUV images."]
pub const TJCS_TJCS_GRAY: TJCS = 2;
#[doc = " CMYK colorspace"]
#[doc = ""]
#[doc = " When generating the JPEG image, the C, M, Y, and K components in the"]
#[doc = " source image are reordered into image planes, but no colorspace conversion"]
#[doc = " or subsampling is performed.  CMYK JPEG images can only be generated from"]
#[doc = " and decompressed to packed-pixel images with the CMYK pixel format."]
pub const TJCS_TJCS_CMYK: TJCS = 3;
#[doc = " YCCK colorspace"]
#[doc = ""]
#[doc = " YCCK (AKA \"YCbCrK\") is not an absolute colorspace but rather a"]
#[doc = " mathematical transformation of CMYK designed solely for storage and"]
#[doc = " transmission.  It is to CMYK as YCbCr is to RGB.  CMYK pixels can be"]
#[doc = " reversibly transformed into YCCK, and as with YCbCr, the chrominance"]
#[doc = " components in the YCCK pixels can be subsampled without incurring major"]
#[doc = " perceptual loss.  YCCK JPEG images can only be generated from and"]
#[doc = " decompressed to packed-pixel images with the CMYK pixel format."]
pub const TJCS_TJCS_YCCK: TJCS = 4;
#[doc = " JPEG colorspaces"]
pub type TJCS = libc::c_uint;
#[doc = " Error handling behavior"]
#[doc = ""]
#[doc = " **Value**"]
#[doc = " - `0` *[default]* Allow the current compression/decompression/transform"]
#[doc = " operation to complete unless a fatal error is encountered."]
#[doc = " - `1` Immediately discontinue the current"]
#[doc = " compression/decompression/transform operation if a warning (non-fatal"]
#[doc = " error) occurs."]
pub const TJPARAM_TJPARAM_STOPONWARNING: TJPARAM = 0;
#[doc = " Row order in packed-pixel source/destination images"]
#[doc = ""]
#[doc = " **Value**"]
#[doc = " - `0` *[default]* top-down (X11) order"]
#[doc = " - `1` bottom-up (Windows, OpenGL) order"]
pub const TJPARAM_TJPARAM_BOTTOMUP: TJPARAM = 1;
#[doc = " JPEG destination buffer (re)allocation [compression, lossless"]
#[doc = " transformation]"]
#[doc = ""]
#[doc = " **Value**"]
#[doc = " - `0` *[default]* Attempt to allocate or reallocate the JPEG destination"]
#[doc = " buffer as needed."]
#[doc = " - `1` Generate an error if the JPEG destination buffer is invalid or too"]
#[doc = " small."]
pub const TJPARAM_TJPARAM_NOREALLOC: TJPARAM = 2;
#[doc = " Perceptual quality of lossy JPEG images [compression only]"]
#[doc = ""]
#[doc = " **Value**"]
#[doc = " - `1`-`100` (`1` = worst quality but best compression, `100` = best"]
#[doc = " quality but worst compression) *[no default; must be explicitly"]
#[doc = " specified]*"]
pub const TJPARAM_TJPARAM_QUALITY: TJPARAM = 3;
#[doc = " Chrominance subsampling level"]
#[doc = ""]
#[doc = " The JPEG or YUV image uses (decompression, decoding) or will use (lossy"]
#[doc = " compression, encoding) the specified level of chrominance subsampling."]
#[doc = ""]
#[doc = " **Value**"]
#[doc = " - One of the @ref TJSAMP \"chrominance subsampling options\" *[no default;"]
#[doc = " must be explicitly specified for lossy compression, encoding, and"]
#[doc = " decoding]*"]
pub const TJPARAM_TJPARAM_SUBSAMP: TJPARAM = 4;
#[doc = " JPEG width (in pixels) [decompression only, read-only]"]
pub const TJPARAM_TJPARAM_JPEGWIDTH: TJPARAM = 5;
#[doc = " JPEG height (in pixels) [decompression only, read-only]"]
pub const TJPARAM_TJPARAM_JPEGHEIGHT: TJPARAM = 6;
#[doc = " Data precision (bits per sample)"]
#[doc = ""]
#[doc = " The JPEG image uses (decompression) or will use (lossless compression) the"]
#[doc = " specified number of bits per sample.  This parameter also specifies the"]
#[doc = " target data precision when loading a PBMPLUS file with #tj3LoadImage8(),"]
#[doc = " #tj3LoadImage12(), or #tj3LoadImage16() and the source data precision when"]
#[doc = " saving a PBMPLUS file with #tj3SaveImage8(), #tj3SaveImage12(), or"]
#[doc = " #tj3SaveImage16()."]
#[doc = ""]
#[doc = " The data precision is the number of bits in the maximum sample value,"]
#[doc = " which may not be the same as the width of the data type used to store the"]
#[doc = " sample."]
#[doc = ""]
#[doc = " **Value**"]
#[doc = " - `8` or `12` for lossy JPEG images; `2` to `16` for lossless JPEG and"]
#[doc = " PBMPLUS images"]
#[doc = ""]
#[doc = " 12-bit JPEG data precision implies #TJPARAM_OPTIMIZE unless"]
#[doc = " #TJPARAM_ARITHMETIC is set."]
pub const TJPARAM_TJPARAM_PRECISION: TJPARAM = 7;
#[doc = " JPEG colorspace"]
#[doc = ""]
#[doc = " The JPEG image uses (decompression) or will use (lossy compression) the"]
#[doc = " specified colorspace."]
#[doc = ""]
#[doc = " **Value**"]
#[doc = " - One of the @ref TJCS \"JPEG colorspaces\" *[default for lossy compression:"]
#[doc = " automatically selected based on the subsampling level and pixel format]*"]
pub const TJPARAM_TJPARAM_COLORSPACE: TJPARAM = 8;
#[doc = " Chrominance upsampling algorithm [lossy decompression only]"]
#[doc = ""]
#[doc = " **Value**"]
#[doc = " - `0` *[default]* Use smooth upsampling when decompressing a JPEG image"]
#[doc = " that was generated using chrominance subsampling.  This creates a smooth"]
#[doc = " transition between neighboring chrominance components in order to reduce"]
#[doc = " upsampling artifacts in the decompressed image."]
#[doc = " - `1` Use the fastest chrominance upsampling algorithm available, which"]
#[doc = " may combine upsampling with color conversion."]
pub const TJPARAM_TJPARAM_FASTUPSAMPLE: TJPARAM = 9;
#[doc = " DCT/IDCT algorithm [lossy compression and decompression]"]
#[doc = ""]
#[doc = " **Value**"]
#[doc = " - `0` *[default]* Use the most accurate DCT/IDCT algorithm available."]
#[doc = " - `1` Use the fastest DCT/IDCT algorithm available."]
#[doc = ""]
#[doc = " This parameter is provided mainly for backward compatibility with libjpeg,"]
#[doc = " which historically implemented several different DCT/IDCT algorithms"]
#[doc = " because of performance limitations with 1990s CPUs.  In the libjpeg-turbo"]
#[doc = " implementation of the TurboJPEG API:"]
#[doc = " - The \"fast\" and \"accurate\" DCT/IDCT algorithms perform similarly on"]
#[doc = " modern x86/x86-64 CPUs that support AVX2 instructions."]
#[doc = " - The \"fast\" algorithm is generally only about 5-15% faster than the"]
#[doc = " \"accurate\" algorithm on other types of CPUs."]
#[doc = " - The difference in accuracy between the \"fast\" and \"accurate\" algorithms"]
#[doc = " is the most pronounced at JPEG quality levels above 90 and tends to be"]
#[doc = " more pronounced with decompression than with compression."]
#[doc = " - For JPEG quality levels above 97, the \"fast\" algorithm degrades and is"]
#[doc = " not fully accelerated, so it is slower than the \"accurate\" algorithm."]
pub const TJPARAM_TJPARAM_FASTDCT: TJPARAM = 10;
#[doc = " Huffman table optimization [lossy compression, lossless transformation]"]
#[doc = ""]
#[doc = " **Value**"]
#[doc = " - `0` *[default]* The JPEG image will use the default Huffman tables."]
#[doc = " - `1` Optimal Huffman tables will be computed for the JPEG image.  For"]
#[doc = " lossless transformation, this can also be specified using"]
#[doc = " #TJXOPT_OPTIMIZE."]
#[doc = ""]
#[doc = " Huffman table optimization improves compression slightly (generally 5% or"]
#[doc = " less), but it reduces compression performance considerably."]
pub const TJPARAM_TJPARAM_OPTIMIZE: TJPARAM = 11;
#[doc = " Progressive JPEG"]
#[doc = ""]
#[doc = " In a progressive JPEG image, the DCT coefficients are split across"]
#[doc = " multiple \"scans\" of increasing quality.  Thus, a low-quality scan"]
#[doc = " containing the lowest-frequency DCT coefficients can be transmitted first"]
#[doc = " and refined with subsequent higher-quality scans containing"]
#[doc = " higher-frequency DCT coefficients.  When using Huffman entropy coding, the"]
#[doc = " progressive JPEG format also provides an \"end-of-bands (EOB) run\" feature"]
#[doc = " that allows large groups of zeroes, potentially spanning multiple MCUs,"]
#[doc = " to be represented using only a few bytes."]
#[doc = ""]
#[doc = " **Value**"]
#[doc = " - `0` *[default for compression, lossless transformation]* The lossy JPEG"]
#[doc = " image is (decompression) or will be (compression, lossless transformation)"]
#[doc = " single-scan."]
#[doc = " - `1` The lossy JPEG image is (decompression) or will be (compression,"]
#[doc = " lossless transformation) progressive.  For lossless transformation, this"]
#[doc = " can also be specified using #TJXOPT_PROGRESSIVE."]
#[doc = ""]
#[doc = " Progressive JPEG images generally have better compression ratios than"]
#[doc = " single-scan JPEG images (much better if the image has large areas of solid"]
#[doc = " color), but progressive JPEG compression and decompression is considerably"]
#[doc = " slower than single-scan JPEG compression and decompression.  Can be"]
#[doc = " combined with #TJPARAM_ARITHMETIC.  Implies #TJPARAM_OPTIMIZE unless"]
#[doc = " #TJPARAM_ARITHMETIC is also set."]
pub const TJPARAM_TJPARAM_PROGRESSIVE: TJPARAM = 12;
#[doc = " Progressive JPEG scan limit for lossy JPEG images [decompression, lossless"]
#[doc = " transformation]"]
#[doc = ""]
#[doc = " Setting this parameter causes the decompression and transform functions to"]
#[doc = " return an error if the number of scans in a progressive JPEG image exceeds"]
#[doc = " the specified limit.  The primary purpose of this is to allow"]
#[doc = " security-critical applications to guard against an exploit of the"]
#[doc = " progressive JPEG format described in"]
#[doc = " <a href=\"https://libjpeg-turbo.org/pmwiki/uploads/About/TwoIssueswiththeJPEGStandard.pdf\" target=\"_blank\">this report</a>."]
#[doc = ""]
#[doc = " **Value**"]
#[doc = " - maximum number of progressive JPEG scans that the decompression and"]
#[doc = " transform functions will process *[default: `0` (no limit)]*"]
#[doc = ""]
#[doc = " @see #TJPARAM_PROGRESSIVE"]
pub const TJPARAM_TJPARAM_SCANLIMIT: TJPARAM = 13;
#[doc = " Arithmetic entropy coding"]
#[doc = ""]
#[doc = " **Value**"]
#[doc = " - `0` *[default for compression, lossless transformation]* The lossy JPEG"]
#[doc = " image uses (decompression) or will use (compression, lossless"]
#[doc = " transformation) Huffman entropy coding."]
#[doc = " - `1` The lossy JPEG image uses (decompression) or will use (compression,"]
#[doc = " lossless transformation) arithmetic entropy coding.  For lossless"]
#[doc = " transformation, this can also be specified using #TJXOPT_ARITHMETIC."]
#[doc = ""]
#[doc = " Arithmetic entropy coding generally improves compression relative to"]
#[doc = " Huffman entropy coding, but it reduces compression and decompression"]
#[doc = " performance considerably.  Can be combined with #TJPARAM_PROGRESSIVE."]
pub const TJPARAM_TJPARAM_ARITHMETIC: TJPARAM = 14;
#[doc = " Lossless JPEG"]
#[doc = ""]
#[doc = " **Value**"]
#[doc = " - `0` *[default for compression]* The JPEG image is (decompression) or"]
#[doc = " will be (compression) lossy/DCT-based."]
#[doc = " - `1` The JPEG image is (decompression) or will be (compression)"]
#[doc = " lossless/predictive."]
#[doc = ""]
#[doc = " In most cases, lossless JPEG compression and decompression is considerably"]
#[doc = " slower than lossy JPEG compression and decompression, and lossless JPEG"]
#[doc = " images are much larger than lossy JPEG images.  Thus, lossless JPEG images"]
#[doc = " are typically used only for applications that require mathematically"]
#[doc = " lossless compression.  Also note that the following features are not"]
#[doc = " available with lossless JPEG images:"]
#[doc = " - Colorspace conversion (lossless JPEG images always use #TJCS_RGB,"]
#[doc = " #TJCS_GRAY, or #TJCS_CMYK, depending on the pixel format of the source"]
#[doc = " image)"]
#[doc = " - Chrominance subsampling (lossless JPEG images always use #TJSAMP_444)"]
#[doc = " - JPEG quality selection"]
#[doc = " - DCT/IDCT algorithm selection"]
#[doc = " - Progressive JPEG"]
#[doc = " - Arithmetic entropy coding"]
#[doc = " - Compression from/decompression to planar YUV images"]
#[doc = " - Decompression scaling"]
#[doc = " - Lossless transformation"]
#[doc = ""]
#[doc = " @see #TJPARAM_LOSSLESSPSV, #TJPARAM_LOSSLESSPT"]
pub const TJPARAM_TJPARAM_LOSSLESS: TJPARAM = 15;
#[doc = " Lossless JPEG predictor selection value (PSV)"]
#[doc = ""]
#[doc = " **Value**"]
#[doc = " - `1`-`7` *[default for compression: `1`]*"]
#[doc = ""]
#[doc = " Lossless JPEG compression shares no algorithms with lossy JPEG"]
#[doc = " compression.  Instead, it uses differential pulse-code modulation (DPCM),"]
#[doc = " an algorithm whereby each sample is encoded as the difference between the"]
#[doc = " sample's value and a \"predictor\", which is based on the values of"]
#[doc = " neighboring samples.  If Ra is the sample immediately to the left of the"]
#[doc = " current sample, Rb is the sample immediately above the current sample, and"]
#[doc = " Rc is the sample diagonally to the left and above the current sample, then"]
#[doc = " the relationship between the predictor selection value and the predictor"]
#[doc = " is as follows:"]
#[doc = ""]
#[doc = " PSV | Predictor"]
#[doc = " ----|----------"]
#[doc = " 1   | Ra"]
#[doc = " 2   | Rb"]
#[doc = " 3   | Rc"]
#[doc = " 4   | Ra + Rb – Rc"]
#[doc = " 5   | Ra + (Rb – Rc) / 2"]
#[doc = " 6   | Rb + (Ra – Rc) / 2"]
#[doc = " 7   | (Ra + Rb) / 2"]
#[doc = ""]
#[doc = " Predictors 1-3 are 1-dimensional predictors, whereas Predictors 4-7 are"]
#[doc = " 2-dimensional predictors.  The best predictor for a particular image"]
#[doc = " depends on the image."]
#[doc = ""]
#[doc = " @see #TJPARAM_LOSSLESS"]
pub const TJPARAM_TJPARAM_LOSSLESSPSV: TJPARAM = 16;
#[doc = " Lossless JPEG point transform (Pt)"]
#[doc = ""]
#[doc = " **Value**"]
#[doc = " - `0` through ***precision*** *- 1*, where ***precision*** is the JPEG"]
#[doc = " data precision in bits *[default for compression: `0`]*"]
#[doc = ""]
#[doc = " A point transform value of `0` is necessary in order to generate a fully"]
#[doc = " lossless JPEG image.  (A non-zero point transform value right-shifts the"]
#[doc = " input samples by the specified number of bits, which is effectively a form"]
#[doc = " of lossy color quantization.)"]
#[doc = ""]
#[doc = " @see #TJPARAM_LOSSLESS, #TJPARAM_PRECISION"]
pub const TJPARAM_TJPARAM_LOSSLESSPT: TJPARAM = 17;
#[doc = " JPEG restart marker interval in MCUs [lossy compression,"]
#[doc = " lossless transformation]"]
#[doc = ""]
#[doc = " The nature of entropy coding is such that a corrupt JPEG image cannot"]
#[doc = " be decompressed beyond the point of corruption unless it contains restart"]
#[doc = " markers.  A restart marker stops and restarts the entropy coding algorithm"]
#[doc = " so that, if a JPEG image is corrupted, decompression can resume at the"]
#[doc = " next marker.  Thus, adding more restart markers improves the fault"]
#[doc = " tolerance of the JPEG image, but adding too many restart markers can"]
#[doc = " adversely affect the compression ratio and performance."]
#[doc = ""]
#[doc = " In typical JPEG images, an MCU (Minimum Coded Unit) is the minimum set of"]
#[doc = " interleaved \"data units\" (8x8 DCT blocks if the image is lossy or samples"]
#[doc = " if the image is lossless) necessary to represent at least one data unit"]
#[doc = " per component.  (For example, an MCU in an interleaved lossy JPEG image"]
#[doc = " that uses 4:2:2 subsampling consists of two luminance blocks followed by"]
#[doc = " one block for each chrominance component.)  In single-component or"]
#[doc = " non-interleaved JPEG images, an MCU is the same as a data unit."]
#[doc = ""]
#[doc = " **Value**"]
#[doc = " - the number of MCUs between each restart marker *[default: `0` (no"]
#[doc = " restart markers)]*"]
#[doc = ""]
#[doc = " Setting this parameter to a non-zero value sets #TJPARAM_RESTARTROWS to 0."]
pub const TJPARAM_TJPARAM_RESTARTBLOCKS: TJPARAM = 18;
#[doc = " JPEG restart marker interval in MCU rows [compression,"]
#[doc = " lossless transformation]"]
#[doc = ""]
#[doc = " See #TJPARAM_RESTARTBLOCKS for a description of restart markers and MCUs."]
#[doc = " An MCU row is a row of MCUs spanning the entire width of the image."]
#[doc = ""]
#[doc = " **Value**"]
#[doc = " - the number of MCU rows between each restart marker *[default: `0` (no"]
#[doc = " restart markers)]*"]
#[doc = ""]
#[doc = " Setting this parameter to a non-zero value sets #TJPARAM_RESTARTBLOCKS to"]
#[doc = " 0."]
pub const TJPARAM_TJPARAM_RESTARTROWS: TJPARAM = 19;
#[doc = " JPEG horizontal pixel density"]
#[doc = ""]
#[doc = " **Value**"]
#[doc = " - The JPEG image has (decompression) or will have (compression) the"]
#[doc = " specified horizontal pixel density *[default for compression: `1`]*."]
#[doc = ""]
#[doc = " This value is stored in or read from the JPEG header.  It does not affect"]
#[doc = " the contents of the JPEG image.  Note that this parameter is set by"]
#[doc = " #tj3LoadImage8() when loading a Windows BMP file that contains pixel"]
#[doc = " density information, and the value of this parameter is stored to a"]
#[doc = " Windows BMP file by #tj3SaveImage8() if the value of #TJPARAM_DENSITYUNITS"]
#[doc = " is `2`."]
#[doc = ""]
#[doc = " This parameter has no effect unless the JPEG colorspace (see"]
#[doc = " #TJPARAM_COLORSPACE) is #TJCS_YCbCr or #TJCS_GRAY."]
#[doc = ""]
#[doc = " @see TJPARAM_DENSITYUNITS"]
pub const TJPARAM_TJPARAM_XDENSITY: TJPARAM = 20;
#[doc = " JPEG vertical pixel density"]
#[doc = ""]
#[doc = " **Value**"]
#[doc = " - The JPEG image has (decompression) or will have (compression) the"]
#[doc = " specified vertical pixel density *[default for compression: `1`]*."]
#[doc = ""]
#[doc = " This value is stored in or read from the JPEG header.  It does not affect"]
#[doc = " the contents of the JPEG image.  Note that this parameter is set by"]
#[doc = " #tj3LoadImage8() when loading a Windows BMP file that contains pixel"]
#[doc = " density information, and the value of this parameter is stored to a"]
#[doc = " Windows BMP file by #tj3SaveImage8() if the value of #TJPARAM_DENSITYUNITS"]
#[doc = " is `2`."]
#[doc = ""]
#[doc = " This parameter has no effect unless the JPEG colorspace (see"]
#[doc = " #TJPARAM_COLORSPACE) is #TJCS_YCbCr or #TJCS_GRAY."]
#[doc = ""]
#[doc = " @see TJPARAM_DENSITYUNITS"]
pub const TJPARAM_TJPARAM_YDENSITY: TJPARAM = 21;
#[doc = " JPEG pixel density units"]
#[doc = ""]
#[doc = " **Value**"]
#[doc = " - `0` *[default for compression]* The pixel density of the JPEG image is"]
#[doc = " expressed (decompression) or will be expressed (compression) in unknown"]
#[doc = " units."]
#[doc = " - `1` The pixel density of the JPEG image is expressed (decompression) or"]
#[doc = " will be expressed (compression) in units of pixels/inch."]
#[doc = " - `2` The pixel density of the JPEG image is expressed (decompression) or"]
#[doc = " will be expressed (compression) in units of pixels/cm."]
#[doc = ""]
#[doc = " This value is stored in or read from the JPEG header.  It does not affect"]
#[doc = " the contents of the JPEG image.  Note that this parameter is set by"]
#[doc = " #tj3LoadImage8() when loading a Windows BMP file that contains pixel"]
#[doc = " density information, and the value of this parameter is stored to a"]
#[doc = " Windows BMP file by #tj3SaveImage8() if the value is `2`."]
#[doc = ""]
#[doc = " This parameter has no effect unless the JPEG colorspace (see"]
#[doc = " #TJPARAM_COLORSPACE) is #TJCS_YCbCr or #TJCS_GRAY."]
#[doc = ""]
#[doc = " @see TJPARAM_XDENSITY, TJPARAM_YDENSITY"]
pub const TJPARAM_TJPARAM_DENSITYUNITS: TJPARAM = 22;
#[doc = " Memory limit for intermediate buffers"]
#[doc = ""]
#[doc = " **Value**"]
#[doc = " - the maximum amount of memory (in megabytes) that will be allocated for"]
#[doc = " intermediate buffers, which are used with progressive JPEG compression and"]
#[doc = " decompression, Huffman table optimization, lossless JPEG compression, and"]
#[doc = " lossless transformation *[default: `0` (no limit)]*"]
pub const TJPARAM_TJPARAM_MAXMEMORY: TJPARAM = 23;
#[doc = " Image size limit [decompression, lossless transformation, packed-pixel"]
#[doc = " image loading]"]
#[doc = ""]
#[doc = " Setting this parameter causes the decompression, transform, and image"]
#[doc = " loading functions to return an error if the number of pixels in the source"]
#[doc = " image exceeds the specified limit.  This allows security-critical"]
#[doc = " applications to guard against excessive memory consumption."]
#[doc = ""]
#[doc = " **Value**"]
#[doc = " - maximum number of pixels that the decompression, transform, and image"]
#[doc = " loading functions will process *[default: `0` (no limit)]*"]
pub const TJPARAM_TJPARAM_MAXPIXELS: TJPARAM = 24;
#[doc = " Marker copying behavior [decompression, lossless transformation]"]
#[doc = ""]
#[doc = " **Value [lossless transformation]**"]
#[doc = " - `0` Do not copy any extra markers (including comments, JFIF thumbnails,"]
#[doc = " Exif data, and ICC profile data) from the source image to the destination"]
#[doc = " image."]
#[doc = " - `1` Do not copy any extra markers, except comment (COM) markers, from"]
#[doc = " the source image to the destination image."]
#[doc = " - `2` *[default]* Copy all extra markers from the source image to the"]
#[doc = " destination image."]
#[doc = " - `3` Copy all extra markers, except ICC profile data (APP2 markers), from"]
#[doc = " the source image to the destination image."]
#[doc = " - `4` Do not copy any extra markers, except ICC profile data (APP2"]
#[doc = " markers), from the source image to the destination image."]
#[doc = ""]
#[doc = " #TJXOPT_COPYNONE overrides this parameter for a particular transform."]
#[doc = " This parameter overrides any ICC profile that was previously associated"]
#[doc = " with the TurboJPEG instance using #tj3SetICCProfile()."]
#[doc = ""]
#[doc = " When decompressing, #tj3DecompressHeader() extracts the ICC profile from a"]
#[doc = " JPEG image if this parameter is set to `2` or `4`.  #tj3GetICCProfile()"]
#[doc = " can then be used to retrieve the profile."]
pub const TJPARAM_TJPARAM_SAVEMARKERS: TJPARAM = 25;
#[doc = " Parameters"]
pub type TJPARAM = libc::c_uint;
#[doc = " The error was non-fatal and recoverable, but the destination image may"]
#[doc = " still be corrupt."]
pub const TJERR_TJERR_WARNING: TJERR = 0;
#[doc = " The error was fatal and non-recoverable."]
pub const TJERR_TJERR_FATAL: TJERR = 1;
#[doc = " Error codes"]
pub type TJERR = libc::c_uint;
#[doc = " Do not transform the position of the image pixels."]
pub const TJXOP_TJXOP_NONE: TJXOP = 0;
#[doc = " Flip (mirror) image horizontally.  This transform is imperfect if there"]
#[doc = " are any partial iMCUs on the right edge (see #TJXOPT_PERFECT.)"]
pub const TJXOP_TJXOP_HFLIP: TJXOP = 1;
#[doc = " Flip (mirror) image vertically.  This transform is imperfect if there are"]
#[doc = " any partial iMCUs on the bottom edge (see #TJXOPT_PERFECT.)"]
pub const TJXOP_TJXOP_VFLIP: TJXOP = 2;
#[doc = " Transpose image (flip/mirror along upper left to lower right axis.)  This"]
#[doc = " transform is always perfect."]
pub const TJXOP_TJXOP_TRANSPOSE: TJXOP = 3;
#[doc = " Transverse transpose image (flip/mirror along upper right to lower left"]
#[doc = " axis.)  This transform is imperfect if there are any partial iMCUs in the"]
#[doc = " image (see #TJXOPT_PERFECT.)"]
pub const TJXOP_TJXOP_TRANSVERSE: TJXOP = 4;
#[doc = " Rotate image clockwise by 90 degrees.  This transform is imperfect if"]
#[doc = " there are any partial iMCUs on the bottom edge (see #TJXOPT_PERFECT.)"]
pub const TJXOP_TJXOP_ROT90: TJXOP = 5;
#[doc = " Rotate image 180 degrees.  This transform is imperfect if there are any"]
#[doc = " partial iMCUs in the image (see #TJXOPT_PERFECT.)"]
pub const TJXOP_TJXOP_ROT180: TJXOP = 6;
#[doc = " Rotate image counter-clockwise by 90 degrees.  This transform is imperfect"]
#[doc = " if there are any partial iMCUs on the right edge (see #TJXOPT_PERFECT.)"]
pub const TJXOP_TJXOP_ROT270: TJXOP = 7;
#[doc = " Transform operations for #tj3Transform()"]
pub type TJXOP = libc::c_uint;
#[doc = " Scaling factor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tjscalingfactor {
    #[doc = " Numerator"]
    pub num: libc::c_int,
    #[doc = " Denominator"]
    pub denom: libc::c_int,
}
#[test]
fn bindgen_test_layout_tjscalingfactor() {
    assert_eq!(
        ::core::mem::size_of::<tjscalingfactor>(),
        8usize,
        concat!("Size of: ", stringify!(tjscalingfactor))
    );
    assert_eq!(
        ::core::mem::align_of::<tjscalingfactor>(),
        4usize,
        concat!("Alignment of ", stringify!(tjscalingfactor))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tjscalingfactor>())).num as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tjscalingfactor),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tjscalingfactor>())).denom as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tjscalingfactor),
            "::",
            stringify!(denom)
        )
    );
}
#[doc = " Cropping region"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tjregion {
    #[doc = " The left boundary of the cropping region.  For lossless transformation,"]
    #[doc = " this must be evenly divisible by the iMCU width (see #tjMCUWidth) of the"]
    #[doc = " destination image.  For decompression, this must be evenly divisible by"]
    #[doc = " the scaled iMCU width of the source image."]
    pub x: libc::c_int,
    #[doc = " The upper boundary of the cropping region.  For lossless transformation,"]
    #[doc = " this must be evenly divisible by the iMCU height (see #tjMCUHeight) of the"]
    #[doc = " destination image."]
    pub y: libc::c_int,
    #[doc = " The width of the cropping region.  Setting this to 0 is the equivalent of"]
    #[doc = " setting it to the width of the source JPEG image - x."]
    pub w: libc::c_int,
    #[doc = " The height of the cropping region.  Setting this to 0 is the equivalent of"]
    #[doc = " setting it to the height of the source JPEG image - y."]
    pub h: libc::c_int,
}
#[test]
fn bindgen_test_layout_tjregion() {
    assert_eq!(
        ::core::mem::size_of::<tjregion>(),
        16usize,
        concat!("Size of: ", stringify!(tjregion))
    );
    assert_eq!(
        ::core::mem::align_of::<tjregion>(),
        4usize,
        concat!("Alignment of ", stringify!(tjregion))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tjregion>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tjregion),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tjregion>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tjregion),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tjregion>())).w as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tjregion),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tjregion>())).h as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tjregion),
            "::",
            stringify!(h)
        )
    );
}
extern "C" {
    pub static TJUNCROPPED: tjregion;
}
#[doc = " Lossless transform"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tjtransform {
    #[doc = " Cropping region"]
    pub r: tjregion,
    #[doc = " One of the @ref TJXOP \"transform operations\""]
    pub op: libc::c_int,
    #[doc = " The bitwise OR of one of more of the @ref TJXOPT_ARITHMETIC"]
    #[doc = " \"transform options\""]
    pub options: libc::c_int,
    #[doc = " Arbitrary data that can be accessed within the body of the callback"]
    #[doc = " function"]
    pub data: *mut libc::c_void,
    #[doc = " A callback function that can be used to modify the DCT coefficients after"]
    #[doc = " they are losslessly transformed but before they are transcoded to a new"]
    #[doc = " JPEG image.  This allows for custom filters or other transformations to be"]
    #[doc = " applied in the frequency domain."]
    #[doc = ""]
    #[doc = " @param coeffs pointer to an array of transformed DCT coefficients.  (NOTE:"]
    #[doc = " This pointer is not guaranteed to be valid once the callback returns, so"]
    #[doc = " applications wishing to hand off the DCT coefficients to another function"]
    #[doc = " or library should make a copy of them within the body of the callback.)"]
    #[doc = ""]
    #[doc = " @param arrayRegion #tjregion structure containing the width and height of"]
    #[doc = " the array pointed to by `coeffs` as well as its offset relative to the"]
    #[doc = " component plane.  TurboJPEG implementations may choose to split each"]
    #[doc = " component plane into multiple DCT coefficient arrays and call the callback"]
    #[doc = " function once for each array."]
    #[doc = ""]
    #[doc = " @param planeRegion #tjregion structure containing the width and height of"]
    #[doc = " the component plane to which `coeffs` belongs"]
    #[doc = ""]
    #[doc = " @param componentID ID number of the component plane to which `coeffs`"]
    #[doc = " belongs.  (Y, Cb, and Cr have, respectively, ID's of 0, 1, and 2 in"]
    #[doc = " typical JPEG images.)"]
    #[doc = ""]
    #[doc = " @param transformID ID number of the transformed image to which `coeffs`"]
    #[doc = " belongs.  This is the same as the index of the transform in the"]
    #[doc = " `transforms` array that was passed to #tj3Transform()."]
    #[doc = ""]
    #[doc = " @param transform a pointer to a #tjtransform structure that specifies the"]
    #[doc = " parameters and/or cropping region for this transform"]
    #[doc = ""]
    #[doc = " @return 0 if the callback was successful, or -1 if an error occurred."]
    pub customFilter: ::core::option::Option<
        unsafe extern "C" fn(
            coeffs: *mut libc::c_short,
            arrayRegion: tjregion,
            planeRegion: tjregion,
            componentID: libc::c_int,
            transformID: libc::c_int,
            transform: *mut tjtransform,
        ) -> libc::c_int,
    >,
}
#[test]
fn bindgen_test_layout_tjtransform() {
    assert_eq!(
        ::core::mem::size_of::<tjtransform>(),
        40usize,
        concat!("Size of: ", stringify!(tjtransform))
    );
    assert_eq!(
        ::core::mem::align_of::<tjtransform>(),
        8usize,
        concat!("Alignment of ", stringify!(tjtransform))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tjtransform>())).r as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tjtransform),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tjtransform>())).op as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tjtransform),
            "::",
            stringify!(op)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tjtransform>())).options as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tjtransform),
            "::",
            stringify!(options)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tjtransform>())).data as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tjtransform),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tjtransform>())).customFilter as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tjtransform),
            "::",
            stringify!(customFilter)
        )
    );
}
#[doc = " TurboJPEG instance handle"]
pub type tjhandle = *mut libc::c_void;
extern "C" {
    pub static TJUNSCALED: tjscalingfactor;
}
extern "C" {
    #[doc = " Create a new TurboJPEG instance."]
    #[doc = ""]
    #[doc = " @param initType one of the @ref TJINIT \"initialization options\""]
    #[doc = ""]
    #[doc = " @return a handle to the newly-created instance, or NULL if an error occurred"]
    #[doc = " (see #tj3GetErrorStr().)"]
    pub fn tj3Init(initType: libc::c_int) -> tjhandle;
}
extern "C" {
    #[doc = " Destroy a TurboJPEG instance."]
    #[doc = ""]
    #[doc = " @param handle handle to a TurboJPEG instance.  If the handle is NULL, then"]
    #[doc = " this function has no effect."]
    pub fn tj3Destroy(handle: tjhandle);
}
extern "C" {
    #[doc = " Returns a descriptive error message explaining why the last command failed."]
    #[doc = ""]
    #[doc = " @param handle handle to a TurboJPEG instance, or NULL if the error was"]
    #[doc = " generated by a global function (but note that retrieving the error message"]
    #[doc = " for a global function is thread-safe only on platforms that support"]
    #[doc = " thread-local storage.)"]
    #[doc = ""]
    #[doc = " @return a descriptive error message explaining why the last command failed."]
    pub fn tj3GetErrorStr(handle: tjhandle) -> *mut libc::c_char;
}
extern "C" {
    #[doc = " Returns a code indicating the severity of the last error.  See"]
    #[doc = " @ref TJERR \"Error codes\"."]
    #[doc = ""]
    #[doc = " @param handle handle to a TurboJPEG instance"]
    #[doc = ""]
    #[doc = " @return a code indicating the severity of the last error.  See"]
    #[doc = " @ref TJERR \"Error codes\"."]
    pub fn tj3GetErrorCode(handle: tjhandle) -> libc::c_int;
}
extern "C" {
    #[doc = " Set the value of a parameter."]
    #[doc = ""]
    #[doc = " @param handle handle to a TurboJPEG instance"]
    #[doc = ""]
    #[doc = " @param param one of the @ref TJPARAM \"parameters\""]
    #[doc = ""]
    #[doc = " @param value value of the parameter (refer to @ref TJPARAM"]
    #[doc = " \"parameter documentation\")"]
    #[doc = ""]
    #[doc = " @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr().)"]
    pub fn tj3Set(handle: tjhandle, param: libc::c_int, value: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the value of a parameter."]
    #[doc = ""]
    #[doc = " @param handle handle to a TurboJPEG instance"]
    #[doc = ""]
    #[doc = " @param param one of the @ref TJPARAM \"parameters\""]
    #[doc = ""]
    #[doc = " @return the value of the specified parameter, or -1 if the value is unknown."]
    pub fn tj3Get(handle: tjhandle, param: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " Allocate a byte buffer for use with TurboJPEG.  You should always use this"]
    #[doc = " function to allocate the JPEG destination buffer(s) for the compression and"]
    #[doc = " transform functions unless you are disabling automatic buffer (re)allocation"]
    #[doc = " (by setting #TJPARAM_NOREALLOC.)"]
    #[doc = ""]
    #[doc = " @param bytes the number of bytes to allocate"]
    #[doc = ""]
    #[doc = " @return a pointer to a newly-allocated buffer with the specified number of"]
    #[doc = " bytes."]
    #[doc = ""]
    #[doc = " @see tj3Free()"]
    pub fn tj3Alloc(bytes: size_t) -> *mut libc::c_void;
}
extern "C" {
    #[doc = " Free a byte buffer previously allocated by TurboJPEG.  You should always use"]
    #[doc = " this function to free JPEG destination buffer(s) that were automatically"]
    #[doc = " (re)allocated by the compression and transform functions or that were"]
    #[doc = " manually allocated using #tj3Alloc()."]
    #[doc = ""]
    #[doc = " @param buffer address of the buffer to free.  If the address is NULL, then"]
    #[doc = " this function has no effect."]
    #[doc = ""]
    #[doc = " @see tj3Alloc()"]
    pub fn tj3Free(buffer: *mut libc::c_void);
}
extern "C" {
    #[doc = " The maximum size of the buffer (in bytes) required to hold a JPEG image with"]
    #[doc = " the given parameters.  The number of bytes returned by this function is"]
    #[doc = " larger than the size of the uncompressed source image.  The reason for this"]
    #[doc = " is that the JPEG format uses 16-bit coefficients, so it is possible for a"]
    #[doc = " very high-quality source image with very high-frequency content to expand"]
    #[doc = " rather than compress when converted to the JPEG format.  Such images"]
    #[doc = " represent very rare corner cases, but since there is no way to predict the"]
    #[doc = " size of a JPEG image prior to compression, the corner cases have to be"]
    #[doc = " handled."]
    #[doc = ""]
    #[doc = " @param width width (in pixels) of the image"]
    #[doc = ""]
    #[doc = " @param height height (in pixels) of the image"]
    #[doc = ""]
    #[doc = " @param jpegSubsamp the level of chrominance subsampling to be used when"]
    #[doc = " generating the JPEG image (see @ref TJSAMP"]
    #[doc = " \"Chrominance subsampling options\".)  #TJSAMP_UNKNOWN is treated like"]
    #[doc = " #TJSAMP_444, since a buffer large enough to hold a JPEG image with no"]
    #[doc = " subsampling should also be large enough to hold a JPEG image with an"]
    #[doc = " arbitrary level of subsampling.  Note that lossless JPEG images always"]
    #[doc = " use #TJSAMP_444."]
    #[doc = ""]
    #[doc = " @return the maximum size of the buffer (in bytes) required to hold the"]
    #[doc = " image, or 0 if the arguments are out of bounds."]
    pub fn tj3JPEGBufSize(
        width: libc::c_int,
        height: libc::c_int,
        jpegSubsamp: libc::c_int,
    ) -> size_t;
}
extern "C" {
    #[doc = " The size of the buffer (in bytes) required to hold a unified planar YUV"]
    #[doc = " image with the given parameters."]
    #[doc = ""]
    #[doc = " @param width width (in pixels) of the image"]
    #[doc = ""]
    #[doc = " @param align row alignment (in bytes) of the image (must be a power of 2.)"]
    #[doc = " Setting this parameter to n specifies that each row in each plane of the"]
    #[doc = " image will be padded to the nearest multiple of n bytes (1 = unpadded.)"]
    #[doc = ""]
    #[doc = " @param height height (in pixels) of the image"]
    #[doc = ""]
    #[doc = " @param subsamp level of chrominance subsampling in the image (see"]
    #[doc = " @ref TJSAMP \"Chrominance subsampling options\".)"]
    #[doc = ""]
    #[doc = " @return the size of the buffer (in bytes) required to hold the image, or 0"]
    #[doc = " if the arguments are out of bounds."]
    pub fn tj3YUVBufSize(
        width: libc::c_int,
        align: libc::c_int,
        height: libc::c_int,
        subsamp: libc::c_int,
    ) -> size_t;
}
extern "C" {
    #[doc = " The size of the buffer (in bytes) required to hold a YUV image plane with"]
    #[doc = " the given parameters."]
    #[doc = ""]
    #[doc = " @param componentID ID number of the image plane (0 = Y, 1 = U/Cb, 2 = V/Cr)"]
    #[doc = ""]
    #[doc = " @param width width (in pixels) of the YUV image.  NOTE: This is the width of"]
    #[doc = " the whole image, not the plane width."]
    #[doc = ""]
    #[doc = " @param stride bytes per row in the image plane.  Setting this to 0 is the"]
    #[doc = " equivalent of setting it to the plane width."]
    #[doc = ""]
    #[doc = " @param height height (in pixels) of the YUV image.  NOTE: This is the height"]
    #[doc = " of the whole image, not the plane height."]
    #[doc = ""]
    #[doc = " @param subsamp level of chrominance subsampling in the image (see"]
    #[doc = " @ref TJSAMP \"Chrominance subsampling options\".)"]
    #[doc = ""]
    #[doc = " @return the size of the buffer (in bytes) required to hold the YUV image"]
    #[doc = " plane, or 0 if the arguments are out of bounds."]
    pub fn tj3YUVPlaneSize(
        componentID: libc::c_int,
        width: libc::c_int,
        stride: libc::c_int,
        height: libc::c_int,
        subsamp: libc::c_int,
    ) -> size_t;
}
extern "C" {
    #[doc = " The plane width of a YUV image plane with the given parameters.  Refer to"]
    #[doc = " @ref YUVnotes \"YUV Image Format Notes\" for a description of plane width."]
    #[doc = ""]
    #[doc = " @param componentID ID number of the image plane (0 = Y, 1 = U/Cb, 2 = V/Cr)"]
    #[doc = ""]
    #[doc = " @param width width (in pixels) of the YUV image"]
    #[doc = ""]
    #[doc = " @param subsamp level of chrominance subsampling in the image (see"]
    #[doc = " @ref TJSAMP \"Chrominance subsampling options\".)"]
    #[doc = ""]
    #[doc = " @return the plane width of a YUV image plane with the given parameters, or 0"]
    #[doc = " if the arguments are out of bounds."]
    pub fn tj3YUVPlaneWidth(
        componentID: libc::c_int,
        width: libc::c_int,
        subsamp: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " The plane height of a YUV image plane with the given parameters.  Refer to"]
    #[doc = " @ref YUVnotes \"YUV Image Format Notes\" for a description of plane height."]
    #[doc = ""]
    #[doc = " @param componentID ID number of the image plane (0 = Y, 1 = U/Cb, 2 = V/Cr)"]
    #[doc = ""]
    #[doc = " @param height height (in pixels) of the YUV image"]
    #[doc = ""]
    #[doc = " @param subsamp level of chrominance subsampling in the image (see"]
    #[doc = " @ref TJSAMP \"Chrominance subsampling options\".)"]
    #[doc = ""]
    #[doc = " @return the plane height of a YUV image plane with the given parameters, or"]
    #[doc = " 0 if the arguments are out of bounds."]
    pub fn tj3YUVPlaneHeight(
        componentID: libc::c_int,
        height: libc::c_int,
        subsamp: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Embed an ICC (International Color Consortium) color management profile in"]
    #[doc = " JPEG images generated by subsequent compression and lossless transformation"]
    #[doc = " operations."]
    #[doc = ""]
    #[doc = " @param handle handle to a TurboJPEG instance that has been initialized for"]
    #[doc = " compression"]
    #[doc = ""]
    #[doc = " @param iccBuf pointer to a byte buffer containing an ICC profile.  A copy is"]
    #[doc = " made of the ICC profile, so this buffer can be freed or reused as soon as"]
    #[doc = " this function returns.  Setting this parameter to NULL or setting `iccSize`"]
    #[doc = " to 0 removes any ICC profile that was previously associated with the"]
    #[doc = " TurboJPEG instance."]
    #[doc = ""]
    #[doc = " @param iccSize size of the ICC profile (in bytes.)  Setting this parameter"]
    #[doc = " to 0 or setting `iccBuf` to NULL removes any ICC profile that was previously"]
    #[doc = " associated with the TurboJPEG instance."]
    #[doc = ""]
    #[doc = " @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr().)"]
    pub fn tj3SetICCProfile(
        handle: tjhandle,
        iccBuf: *mut libc::c_uchar,
        iccSize: size_t,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Compress a packed-pixel RGB, grayscale, or CMYK image with 2 to 8 bits of"]
    #[doc = " data precision per sample into a JPEG image with the same data precision."]
    #[doc = ""]
    #[doc = " @param handle handle to a TurboJPEG instance that has been initialized for"]
    #[doc = " compression"]
    #[doc = ""]
    #[doc = " @param srcBuf pointer to a buffer containing a packed-pixel RGB, grayscale,"]
    #[doc = " or CMYK source image to be compressed.  This buffer should normally be"]
    #[doc = " `pitch * height` samples in size.  However, you can also use this parameter"]
    #[doc = " to compress from a specific region of a larger buffer.  The data precision"]
    #[doc = " of the source image (from 2 to 8 bits per sample) can be specified using"]
    #[doc = " #TJPARAM_PRECISION and defaults to 8 if #TJPARAM_PRECISION is unset or out"]
    #[doc = " of range."]
    #[doc = ""]
    #[doc = " @param width width (in pixels) of the source image"]
    #[doc = ""]
    #[doc = " @param pitch samples per row in the source image.  Normally this should be"]
    #[doc = " <tt>width * #tjPixelSize[pixelFormat]</tt>, if the image is unpadded."]
    #[doc = " (Setting this parameter to 0 is the equivalent of setting it to"]
    #[doc = " <tt>width * #tjPixelSize[pixelFormat]</tt>.)  However, you can also use this"]
    #[doc = " parameter to specify the row alignment/padding of the source image, to skip"]
    #[doc = " rows, or to compress from a specific region of a larger buffer."]
    #[doc = ""]
    #[doc = " @param height height (in pixels) of the source image"]
    #[doc = ""]
    #[doc = " @param pixelFormat pixel format of the source image (see @ref TJPF"]
    #[doc = " \"Pixel formats\".)"]
    #[doc = ""]
    #[doc = " @param jpegBuf address of a pointer to a byte buffer that will receive the"]
    #[doc = " JPEG image.  TurboJPEG has the ability to reallocate the JPEG buffer to"]
    #[doc = " accommodate the size of the JPEG image.  Thus, you can choose to:"]
    #[doc = " -# pre-allocate the JPEG buffer with an arbitrary size using #tj3Alloc() and"]
    #[doc = " let TurboJPEG grow the buffer as needed,"]
    #[doc = " -# set `*jpegBuf` to NULL to tell TurboJPEG to allocate the buffer for you,"]
    #[doc = " or"]
    #[doc = " -# pre-allocate the buffer to a \"worst case\" size determined by calling"]
    #[doc = " #tj3JPEGBufSize() and adding the return value to the size of the ICC profile"]
    #[doc = " (if any) that was previously associated with the TurboJPEG instance (see"]
    #[doc = " #tj3SetICCProfile().)  This should ensure that the buffer never has to be"]
    #[doc = " re-allocated.  (Setting #TJPARAM_NOREALLOC guarantees that it won't be.)"]
    #[doc = " ."]
    #[doc = " If you choose option 1 or 3, then `*jpegSize` should be set to the size of"]
    #[doc = " your pre-allocated buffer.  In any case, unless you have set"]
    #[doc = " #TJPARAM_NOREALLOC, you should always check `*jpegBuf` upon return from this"]
    #[doc = " function, as it may have changed."]
    #[doc = ""]
    #[doc = " @param jpegSize pointer to a size_t variable that holds the size of the JPEG"]
    #[doc = " buffer.  If `*jpegBuf` points to a pre-allocated buffer, then `*jpegSize`"]
    #[doc = " should be set to the size of the buffer.  Upon return, `*jpegSize` will"]
    #[doc = " contain the size of the JPEG image (in bytes.)  If `*jpegBuf` points to a"]
    #[doc = " JPEG buffer that is being reused from a previous call to one of the JPEG"]
    #[doc = " compression functions, then `*jpegSize` is ignored."]
    #[doc = ""]
    #[doc = " @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()"]
    #[doc = " and #tj3GetErrorCode().)"]
    pub fn tj3Compress8(
        handle: tjhandle,
        srcBuf: *const libc::c_uchar,
        width: libc::c_int,
        pitch: libc::c_int,
        height: libc::c_int,
        pixelFormat: libc::c_int,
        jpegBuf: *mut *mut libc::c_uchar,
        jpegSize: *mut size_t,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Compress a packed-pixel RGB, grayscale, or CMYK image with 9 to 12 bits of"]
    #[doc = " data precision per sample into a JPEG image with the same data precision."]
    #[doc = ""]
    #[doc = " @param handle handle to a TurboJPEG instance that has been initialized for"]
    #[doc = " compression"]
    #[doc = ""]
    #[doc = " @param srcBuf pointer to a buffer containing a packed-pixel RGB, grayscale,"]
    #[doc = " or CMYK source image to be compressed.  This buffer should normally be"]
    #[doc = " `pitch * height` samples in size.  However, you can also use this parameter"]
    #[doc = " to compress from a specific region of a larger buffer.  The data precision"]
    #[doc = " of the source image (from 9 to 12 bits per sample) can be specified using"]
    #[doc = " #TJPARAM_PRECISION and defaults to 12 if #TJPARAM_PRECISION is unset or out"]
    #[doc = " of range."]
    #[doc = ""]
    #[doc = " @param width width (in pixels) of the source image"]
    #[doc = ""]
    #[doc = " @param pitch samples per row in the source image.  Normally this should be"]
    #[doc = " <tt>width * #tjPixelSize[pixelFormat]</tt>, if the image is unpadded."]
    #[doc = " (Setting this parameter to 0 is the equivalent of setting it to"]
    #[doc = " <tt>width * #tjPixelSize[pixelFormat]</tt>.)  However, you can also use this"]
    #[doc = " parameter to specify the row alignment/padding of the source image, to skip"]
    #[doc = " rows, or to compress from a specific region of a larger buffer."]
    #[doc = ""]
    #[doc = " @param height height (in pixels) of the source image"]
    #[doc = ""]
    #[doc = " @param pixelFormat pixel format of the source image (see @ref TJPF"]
    #[doc = " \"Pixel formats\".)"]
    #[doc = ""]
    #[doc = " @param jpegBuf address of a pointer to a byte buffer that will receive the"]
    #[doc = " JPEG image.  TurboJPEG has the ability to reallocate the JPEG buffer to"]
    #[doc = " accommodate the size of the JPEG image.  Thus, you can choose to:"]
    #[doc = " -# pre-allocate the JPEG buffer with an arbitrary size using #tj3Alloc() and"]
    #[doc = " let TurboJPEG grow the buffer as needed,"]
    #[doc = " -# set `*jpegBuf` to NULL to tell TurboJPEG to allocate the buffer for you,"]
    #[doc = " or"]
    #[doc = " -# pre-allocate the buffer to a \"worst case\" size determined by calling"]
    #[doc = " #tj3JPEGBufSize() and adding the return value to the size of the ICC profile"]
    #[doc = " (if any) that was previously associated with the TurboJPEG instance (see"]
    #[doc = " #tj3SetICCProfile().)  This should ensure that the buffer never has to be"]
    #[doc = " re-allocated.  (Setting #TJPARAM_NOREALLOC guarantees that it won't be.)"]
    #[doc = " ."]
    #[doc = " If you choose option 1 or 3, then `*jpegSize` should be set to the size of"]
    #[doc = " your pre-allocated buffer.  In any case, unless you have set"]
    #[doc = " #TJPARAM_NOREALLOC, you should always check `*jpegBuf` upon return from this"]
    #[doc = " function, as it may have changed."]
    #[doc = ""]
    #[doc = " @param jpegSize pointer to a size_t variable that holds the size of the JPEG"]
    #[doc = " buffer.  If `*jpegBuf` points to a pre-allocated buffer, then `*jpegSize`"]
    #[doc = " should be set to the size of the buffer.  Upon return, `*jpegSize` will"]
    #[doc = " contain the size of the JPEG image (in bytes.)  If `*jpegBuf` points to a"]
    #[doc = " JPEG buffer that is being reused from a previous call to one of the JPEG"]
    #[doc = " compression functions, then `*jpegSize` is ignored."]
    #[doc = ""]
    #[doc = " @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()"]
    #[doc = " and #tj3GetErrorCode().)"]
    pub fn tj3Compress12(
        handle: tjhandle,
        srcBuf: *const libc::c_short,
        width: libc::c_int,
        pitch: libc::c_int,
        height: libc::c_int,
        pixelFormat: libc::c_int,
        jpegBuf: *mut *mut libc::c_uchar,
        jpegSize: *mut size_t,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Compress a packed-pixel RGB, grayscale, or CMYK image with 13 to 16 bits of"]
    #[doc = " data precision per sample into a lossless JPEG image with the same data"]
    #[doc = " precision."]
    #[doc = ""]
    #[doc = " @param handle handle to a TurboJPEG instance that has been initialized for"]
    #[doc = " compression"]
    #[doc = ""]
    #[doc = " @param srcBuf pointer to a buffer containing a packed-pixel RGB, grayscale,"]
    #[doc = " or CMYK source image to be compressed.  This buffer should normally be"]
    #[doc = " `pitch * height` samples in size.  However, you can also use this parameter"]
    #[doc = " to compress from a specific region of a larger buffer.  The data precision"]
    #[doc = " of the source image (from 13 to 16 bits per sample) can be specified using"]
    #[doc = " #TJPARAM_PRECISION and defaults to 16 if #TJPARAM_PRECISION is unset or out"]
    #[doc = " of range."]
    #[doc = ""]
    #[doc = " @param width width (in pixels) of the source image"]
    #[doc = ""]
    #[doc = " @param pitch samples per row in the source image.  Normally this should be"]
    #[doc = " <tt>width * #tjPixelSize[pixelFormat]</tt>, if the image is unpadded."]
    #[doc = " (Setting this parameter to 0 is the equivalent of setting it to"]
    #[doc = " <tt>width * #tjPixelSize[pixelFormat]</tt>.)  However, you can also use this"]
    #[doc = " parameter to specify the row alignment/padding of the source image, to skip"]
    #[doc = " rows, or to compress from a specific region of a larger buffer."]
    #[doc = ""]
    #[doc = " @param height height (in pixels) of the source image"]
    #[doc = ""]
    #[doc = " @param pixelFormat pixel format of the source image (see @ref TJPF"]
    #[doc = " \"Pixel formats\".)"]
    #[doc = ""]
    #[doc = " @param jpegBuf address of a pointer to a byte buffer that will receive the"]
    #[doc = " JPEG image.  TurboJPEG has the ability to reallocate the JPEG buffer to"]
    #[doc = " accommodate the size of the JPEG image.  Thus, you can choose to:"]
    #[doc = " -# pre-allocate the JPEG buffer with an arbitrary size using #tj3Alloc() and"]
    #[doc = " let TurboJPEG grow the buffer as needed,"]
    #[doc = " -# set `*jpegBuf` to NULL to tell TurboJPEG to allocate the buffer for you,"]
    #[doc = " or"]
    #[doc = " -# pre-allocate the buffer to a \"worst case\" size determined by calling"]
    #[doc = " #tj3JPEGBufSize() and adding the return value to the size of the ICC profile"]
    #[doc = " (if any) that was previously associated with the TurboJPEG instance (see"]
    #[doc = " #tj3SetICCProfile().)  This should ensure that the buffer never has to be"]
    #[doc = " re-allocated.  (Setting #TJPARAM_NOREALLOC guarantees that it won't be.)"]
    #[doc = " ."]
    #[doc = " If you choose option 1 or 3, then `*jpegSize` should be set to the size of"]
    #[doc = " your pre-allocated buffer.  In any case, unless you have set"]
    #[doc = " #TJPARAM_NOREALLOC, you should always check `*jpegBuf` upon return from this"]
    #[doc = " function, as it may have changed."]
    #[doc = ""]
    #[doc = " @param jpegSize pointer to a size_t variable that holds the size of the JPEG"]
    #[doc = " buffer.  If `*jpegBuf` points to a pre-allocated buffer, then `*jpegSize`"]
    #[doc = " should be set to the size of the buffer.  Upon return, `*jpegSize` will"]
    #[doc = " contain the size of the JPEG image (in bytes.)  If `*jpegBuf` points to a"]
    #[doc = " JPEG buffer that is being reused from a previous call to one of the JPEG"]
    #[doc = " compression functions, then `*jpegSize` is ignored."]
    #[doc = ""]
    #[doc = " @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()"]
    #[doc = " and #tj3GetErrorCode().)"]
    pub fn tj3Compress16(
        handle: tjhandle,
        srcBuf: *const libc::c_ushort,
        width: libc::c_int,
        pitch: libc::c_int,
        height: libc::c_int,
        pixelFormat: libc::c_int,
        jpegBuf: *mut *mut libc::c_uchar,
        jpegSize: *mut size_t,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Compress a set of 8-bit-per-sample Y, U (Cb), and V (Cr) image planes into"]
    #[doc = " an 8-bit-per-sample JPEG image."]
    #[doc = ""]
    #[doc = " @param handle handle to a TurboJPEG instance that has been initialized for"]
    #[doc = " compression"]
    #[doc = ""]
    #[doc = " @param srcPlanes an array of pointers to Y, U (Cb), and V (Cr) image planes"]
    #[doc = " (or just a Y plane, if compressing a grayscale image) that contain a YUV"]
    #[doc = " source image to be compressed.  These planes can be contiguous or"]
    #[doc = " non-contiguous in memory.  The size of each plane should match the value"]
    #[doc = " returned by #tj3YUVPlaneSize() for the given image width, height, strides,"]
    #[doc = " and level of chrominance subsampling (see #TJPARAM_SUBSAMP.)  Refer to"]
    #[doc = " @ref YUVnotes \"YUV Image Format Notes\" for more details."]
    #[doc = ""]
    #[doc = " @param width width (in pixels) of the source image.  If the width is not an"]
    #[doc = " even multiple of the iMCU width (see #tjMCUWidth), then an intermediate"]
    #[doc = " buffer copy will be performed."]
    #[doc = ""]
    #[doc = " @param strides an array of integers, each specifying the number of bytes per"]
    #[doc = " row in the corresponding plane of the YUV source image.  Setting the stride"]
    #[doc = " for any plane to 0 is the same as setting it to the plane width (see"]
    #[doc = " @ref YUVnotes \"YUV Image Format Notes\".)  If `strides` is NULL, then the"]
    #[doc = " strides for all planes will be set to their respective plane widths.  You"]
    #[doc = " can adjust the strides in order to specify an arbitrary amount of row"]
    #[doc = " padding in each plane or to create a JPEG image from a subregion of a larger"]
    #[doc = " planar YUV image."]
    #[doc = ""]
    #[doc = " @param height height (in pixels) of the source image.  If the height is not"]
    #[doc = " an even multiple of the iMCU height (see #tjMCUHeight), then an intermediate"]
    #[doc = " buffer copy will be performed."]
    #[doc = ""]
    #[doc = " @param jpegBuf address of a pointer to a byte buffer that will receive the"]
    #[doc = " JPEG image.  TurboJPEG has the ability to reallocate the JPEG buffer to"]
    #[doc = " accommodate the size of the JPEG image.  Thus, you can choose to:"]
    #[doc = " -# pre-allocate the JPEG buffer with an arbitrary size using #tj3Alloc() and"]
    #[doc = " let TurboJPEG grow the buffer as needed,"]
    #[doc = " -# set `*jpegBuf` to NULL to tell TurboJPEG to allocate the buffer for you,"]
    #[doc = " or"]
    #[doc = " -# pre-allocate the buffer to a \"worst case\" size determined by calling"]
    #[doc = " #tj3JPEGBufSize() and adding the return value to the size of the ICC profile"]
    #[doc = " (if any) that was previously associated with the TurboJPEG instance (see"]
    #[doc = " #tj3SetICCProfile().)  This should ensure that the buffer never has to be"]
    #[doc = " re-allocated.  (Setting #TJPARAM_NOREALLOC guarantees that it won't be.)"]
    #[doc = " ."]
    #[doc = " If you choose option 1 or 3, then `*jpegSize` should be set to the size of"]
    #[doc = " your pre-allocated buffer.  In any case, unless you have set"]
    #[doc = " #TJPARAM_NOREALLOC, you should always check `*jpegBuf` upon return from this"]
    #[doc = " function, as it may have changed."]
    #[doc = ""]
    #[doc = " @param jpegSize pointer to a size_t variable that holds the size of the JPEG"]
    #[doc = " buffer.  If `*jpegBuf` points to a pre-allocated buffer, then `*jpegSize`"]
    #[doc = " should be set to the size of the buffer.  Upon return, `*jpegSize` will"]
    #[doc = " contain the size of the JPEG image (in bytes.)  If `*jpegBuf` points to a"]
    #[doc = " JPEG buffer that is being reused from a previous call to one of the JPEG"]
    #[doc = " compression functions, then `*jpegSize` is ignored."]
    #[doc = ""]
    #[doc = " @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()"]
    #[doc = " and #tj3GetErrorCode().)"]
    pub fn tj3CompressFromYUVPlanes8(
        handle: tjhandle,
        srcPlanes: *const *const libc::c_uchar,
        width: libc::c_int,
        strides: *const libc::c_int,
        height: libc::c_int,
        jpegBuf: *mut *mut libc::c_uchar,
        jpegSize: *mut size_t,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Compress an 8-bit-per-sample unified planar YUV image into an"]
    #[doc = " 8-bit-per-sample JPEG image."]
    #[doc = ""]
    #[doc = " @param handle handle to a TurboJPEG instance that has been initialized for"]
    #[doc = " compression"]
    #[doc = ""]
    #[doc = " @param srcBuf pointer to a buffer containing a unified planar YUV source"]
    #[doc = " image to be compressed.  The size of this buffer should match the value"]
    #[doc = " returned by #tj3YUVBufSize() for the given image width, height, row"]
    #[doc = " alignment, and level of chrominance subsampling (see #TJPARAM_SUBSAMP.)  The"]
    #[doc = " Y, U (Cb), and V (Cr) image planes should be stored sequentially in the"]
    #[doc = " buffer.  (Refer to @ref YUVnotes \"YUV Image Format Notes\".)"]
    #[doc = ""]
    #[doc = " @param width width (in pixels) of the source image.  If the width is not an"]
    #[doc = " even multiple of the iMCU width (see #tjMCUWidth), then an intermediate"]
    #[doc = " buffer copy will be performed."]
    #[doc = ""]
    #[doc = " @param align row alignment (in bytes) of the source image (must be a power"]
    #[doc = " of 2.)  Setting this parameter to n indicates that each row in each plane of"]
    #[doc = " the source image is padded to the nearest multiple of n bytes"]
    #[doc = " (1 = unpadded.)"]
    #[doc = ""]
    #[doc = " @param height height (in pixels) of the source image.  If the height is not"]
    #[doc = " an even multiple of the iMCU height (see #tjMCUHeight), then an intermediate"]
    #[doc = " buffer copy will be performed."]
    #[doc = ""]
    #[doc = " @param jpegBuf address of a pointer to a byte buffer that will receive the"]
    #[doc = " JPEG image.  TurboJPEG has the ability to reallocate the JPEG buffer to"]
    #[doc = " accommodate the size of the JPEG image.  Thus, you can choose to:"]
    #[doc = " -# pre-allocate the JPEG buffer with an arbitrary size using #tj3Alloc() and"]
    #[doc = " let TurboJPEG grow the buffer as needed,"]
    #[doc = " -# set `*jpegBuf` to NULL to tell TurboJPEG to allocate the buffer for you,"]
    #[doc = " or"]
    #[doc = " -# pre-allocate the buffer to a \"worst case\" size determined by calling"]
    #[doc = " #tj3JPEGBufSize() and adding the return value to the size of the ICC profile"]
    #[doc = " (if any) that was previously associated with the TurboJPEG instance (see"]
    #[doc = " #tj3SetICCProfile().)  This should ensure that the buffer never has to be"]
    #[doc = " re-allocated.  (Setting #TJPARAM_NOREALLOC guarantees that it won't be.)"]
    #[doc = " ."]
    #[doc = " If you choose option 1 or 3, then `*jpegSize` should be set to the size of"]
    #[doc = " your pre-allocated buffer.  In any case, unless you have set"]
    #[doc = " #TJPARAM_NOREALLOC, you should always check `*jpegBuf` upon return from this"]
    #[doc = " function, as it may have changed."]
    #[doc = ""]
    #[doc = " @param jpegSize pointer to a size_t variable that holds the size of the JPEG"]
    #[doc = " buffer.  If `*jpegBuf` points to a pre-allocated buffer, then `*jpegSize`"]
    #[doc = " should be set to the size of the buffer.  Upon return, `*jpegSize` will"]
    #[doc = " contain the size of the JPEG image (in bytes.)  If `*jpegBuf` points to a"]
    #[doc = " JPEG buffer that is being reused from a previous call to one of the JPEG"]
    #[doc = " compression functions, then `*jpegSize` is ignored."]
    #[doc = ""]
    #[doc = " @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()"]
    #[doc = " and #tj3GetErrorCode().)"]
    pub fn tj3CompressFromYUV8(
        handle: tjhandle,
        srcBuf: *const libc::c_uchar,
        width: libc::c_int,
        align: libc::c_int,
        height: libc::c_int,
        jpegBuf: *mut *mut libc::c_uchar,
        jpegSize: *mut size_t,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Encode an 8-bit-per-sample packed-pixel RGB or grayscale image into separate"]
    #[doc = " 8-bit-per-sample Y, U (Cb), and V (Cr) image planes.  This function performs"]
    #[doc = " color conversion (which is accelerated in the libjpeg-turbo implementation)"]
    #[doc = " but does not execute any of the other steps in the JPEG compression process."]
    #[doc = ""]
    #[doc = " @param handle handle to a TurboJPEG instance that has been initialized for"]
    #[doc = " compression"]
    #[doc = ""]
    #[doc = " @param srcBuf pointer to a buffer containing a packed-pixel RGB or grayscale"]
    #[doc = " source image to be encoded.  This buffer should normally be `pitch * height`"]
    #[doc = " bytes in size.  However, you can also use this parameter to encode from a"]
    #[doc = " specific region of a larger buffer."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @param width width (in pixels) of the source image"]
    #[doc = ""]
    #[doc = " @param pitch bytes per row in the source image.  Normally this should be"]
    #[doc = " <tt>width * #tjPixelSize[pixelFormat]</tt>, if the image is unpadded."]
    #[doc = " (Setting this parameter to 0 is the equivalent of setting it to"]
    #[doc = " <tt>width * #tjPixelSize[pixelFormat]</tt>.)  However, you can also use this"]
    #[doc = " parameter to specify the row alignment/padding of the source image, to skip"]
    #[doc = " rows, or to encode from a specific region of a larger packed-pixel image."]
    #[doc = ""]
    #[doc = " @param height height (in pixels) of the source image"]
    #[doc = ""]
    #[doc = " @param pixelFormat pixel format of the source image (see @ref TJPF"]
    #[doc = " \"Pixel formats\".)"]
    #[doc = ""]
    #[doc = " @param dstPlanes an array of pointers to Y, U (Cb), and V (Cr) image planes"]
    #[doc = " (or just a Y plane, if generating a grayscale image) that will receive the"]
    #[doc = " encoded image.  These planes can be contiguous or non-contiguous in memory."]
    #[doc = " Use #tj3YUVPlaneSize() to determine the appropriate size for each plane"]
    #[doc = " based on the image width, height, strides, and level of chrominance"]
    #[doc = " subsampling (see #TJPARAM_SUBSAMP.)  Refer to @ref YUVnotes"]
    #[doc = " \"YUV Image Format Notes\" for more details."]
    #[doc = ""]
    #[doc = " @param strides an array of integers, each specifying the number of bytes per"]
    #[doc = " row in the corresponding plane of the YUV image.  Setting the stride for any"]
    #[doc = " plane to 0 is the same as setting it to the plane width (see @ref YUVnotes"]
    #[doc = " \"YUV Image Format Notes\".)  If `strides` is NULL, then the strides for all"]
    #[doc = " planes will be set to their respective plane widths.  You can adjust the"]
    #[doc = " strides in order to add an arbitrary amount of row padding to each plane or"]
    #[doc = " to encode an RGB or grayscale image into a subregion of a larger planar YUV"]
    #[doc = " image."]
    #[doc = ""]
    #[doc = " @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()"]
    #[doc = " and #tj3GetErrorCode().)"]
    pub fn tj3EncodeYUVPlanes8(
        handle: tjhandle,
        srcBuf: *const libc::c_uchar,
        width: libc::c_int,
        pitch: libc::c_int,
        height: libc::c_int,
        pixelFormat: libc::c_int,
        dstPlanes: *mut *mut libc::c_uchar,
        strides: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Encode an 8-bit-per-sample packed-pixel RGB or grayscale image into an"]
    #[doc = " 8-bit-per-sample unified planar YUV image.  This function performs color"]
    #[doc = " conversion (which is accelerated in the libjpeg-turbo implementation) but"]
    #[doc = " does not execute any of the other steps in the JPEG compression process."]
    #[doc = ""]
    #[doc = " @param handle handle to a TurboJPEG instance that has been initialized for"]
    #[doc = " compression"]
    #[doc = ""]
    #[doc = " @param srcBuf pointer to a buffer containing a packed-pixel RGB or grayscale"]
    #[doc = " source image to be encoded.  This buffer should normally be `pitch * height`"]
    #[doc = " bytes in size.  However, you can also use this parameter to encode from a"]
    #[doc = " specific region of a larger buffer."]
    #[doc = ""]
    #[doc = " @param width width (in pixels) of the source image"]
    #[doc = ""]
    #[doc = " @param pitch bytes per row in the source image.  Normally this should be"]
    #[doc = " <tt>width * #tjPixelSize[pixelFormat]</tt>, if the image is unpadded."]
    #[doc = " (Setting this parameter to 0 is the equivalent of setting it to"]
    #[doc = " <tt>width * #tjPixelSize[pixelFormat]</tt>.)  However, you can also use this"]
    #[doc = " parameter to specify the row alignment/padding of the source image, to skip"]
    #[doc = " rows, or to encode from a specific region of a larger packed-pixel image."]
    #[doc = ""]
    #[doc = " @param height height (in pixels) of the source image"]
    #[doc = ""]
    #[doc = " @param pixelFormat pixel format of the source image (see @ref TJPF"]
    #[doc = " \"Pixel formats\".)"]
    #[doc = ""]
    #[doc = " @param dstBuf pointer to a buffer that will receive the unified planar YUV"]
    #[doc = " image.  Use #tj3YUVBufSize() to determine the appropriate size for this"]
    #[doc = " buffer based on the image width, height, row alignment, and level of"]
    #[doc = " chrominance subsampling (see #TJPARAM_SUBSAMP.)  The Y, U (Cb), and V (Cr)"]
    #[doc = " image planes will be stored sequentially in the buffer.  (Refer to"]
    #[doc = " @ref YUVnotes \"YUV Image Format Notes\".)"]
    #[doc = ""]
    #[doc = " @param align row alignment (in bytes) of the YUV image (must be a power of"]
    #[doc = " 2.)  Setting this parameter to n will cause each row in each plane of the"]
    #[doc = " YUV image to be padded to the nearest multiple of n bytes (1 = unpadded.)"]
    #[doc = " To generate images suitable for X Video, `align` should be set to 4."]
    #[doc = ""]
    #[doc = " @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()"]
    #[doc = " and #tj3GetErrorCode().)"]
    pub fn tj3EncodeYUV8(
        handle: tjhandle,
        srcBuf: *const libc::c_uchar,
        width: libc::c_int,
        pitch: libc::c_int,
        height: libc::c_int,
        pixelFormat: libc::c_int,
        dstBuf: *mut libc::c_uchar,
        align: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Retrieve information about a JPEG image without decompressing it, or prime"]
    #[doc = " the decompressor with quantization and Huffman tables.  If a JPEG image is"]
    #[doc = " passed to this function, then the @ref TJPARAM \"parameters\" that describe"]
    #[doc = " the JPEG image will be set when the function returns.  If a JPEG image is"]
    #[doc = " passed to this function and #TJPARAM_SAVEMARKERS is set to `2` or `4`, then"]
    #[doc = " the ICC profile (if any) will be extracted from the JPEG image."]
    #[doc = " (#tj3GetICCProfile() can then be used to retrieve the profile.)"]
    #[doc = ""]
    #[doc = " @param handle handle to a TurboJPEG instance that has been initialized for"]
    #[doc = " decompression"]
    #[doc = ""]
    #[doc = " @param jpegBuf pointer to a byte buffer containing a JPEG image or an"]
    #[doc = " \"abbreviated table specification\" (AKA \"tables-only\") datastream.  Passing a"]
    #[doc = " tables-only datastream to this function primes the decompressor with"]
    #[doc = " quantization and Huffman tables that can be used when decompressing"]
    #[doc = " subsequent \"abbreviated image\" datastreams.  This is useful, for instance,"]
    #[doc = " when decompressing video streams in which all frames share the same"]
    #[doc = " quantization and Huffman tables."]
    #[doc = ""]
    #[doc = " @param jpegSize size of the JPEG image or tables-only datastream (in bytes)"]
    #[doc = ""]
    #[doc = " @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()"]
    #[doc = " and #tj3GetErrorCode().)"]
    pub fn tj3DecompressHeader(
        handle: tjhandle,
        jpegBuf: *const libc::c_uchar,
        jpegSize: size_t,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Retrieve the ICC (International Color Consortium) color management profile"]
    #[doc = " (if any) that was previously extracted from a JPEG image."]
    #[doc = ""]
    #[doc = " @note To extract the ICC profile from a JPEG image, call"]
    #[doc = " #tj3DecompressHeader() with #TJPARAM_SAVEMARKERS set to `2` or `4`.  Once"]
    #[doc = " the ICC profile is retrieved, it must be re-extracted before it can be"]
    #[doc = " retrieved again."]
    #[doc = ""]
    #[doc = " @param handle handle to a TurboJPEG instance that has been initialized for"]
    #[doc = " decompression"]
    #[doc = ""]
    #[doc = " @param iccBuf address of a pointer to a byte buffer.  Upon return:"]
    #[doc = " - If `iccBuf` is not NULL and there is an ICC profile to retrieve, then"]
    #[doc = " `*iccBuf` will point to a byte buffer containing the ICC profile.  This"]
    #[doc = " buffer should be freed using #tj3Free()."]
    #[doc = " - If `iccBuf` is not NULL and there is no ICC profile to retrieve, then"]
    #[doc = " `*iccBuf` will be NULL."]
    #[doc = " - If `iccBuf` is NULL, then only the ICC profile size will be retrieved, and"]
    #[doc = " the ICC profile can be retrieved later."]
    #[doc = ""]
    #[doc = " @param iccSize address of a size_t variable.  Upon return, the variable will"]
    #[doc = " contain the ICC profile size (or 0 if there is no ICC profile to retrieve.)"]
    #[doc = ""]
    #[doc = " @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()"]
    #[doc = " and #tj3GetErrorCode().)"]
    pub fn tj3GetICCProfile(
        handle: tjhandle,
        iccBuf: *mut *mut libc::c_uchar,
        iccSize: *mut size_t,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Returns a list of fractional scaling factors that the JPEG decompressor"]
    #[doc = " supports."]
    #[doc = ""]
    #[doc = " @param numScalingFactors pointer to an integer variable that will receive"]
    #[doc = " the number of elements in the list"]
    #[doc = ""]
    #[doc = " @return a pointer to a list of fractional scaling factors, or NULL if an"]
    #[doc = " error is encountered (see #tj3GetErrorStr().)"]
    pub fn tj3GetScalingFactors(numScalingFactors: *mut libc::c_int) -> *mut tjscalingfactor;
}
extern "C" {
    #[doc = " Set the scaling factor for subsequent lossy decompression operations."]
    #[doc = ""]
    #[doc = " @param handle handle to a TurboJPEG instance that has been initialized for"]
    #[doc = " decompression"]
    #[doc = ""]
    #[doc = " @param scalingFactor #tjscalingfactor structure that specifies a fractional"]
    #[doc = " scaling factor that the decompressor supports (see #tj3GetScalingFactors()),"]
    #[doc = " or <tt>#TJUNSCALED</tt> for no scaling.  Decompression scaling is a function"]
    #[doc = " of the IDCT algorithm, so scaling factors are generally limited to multiples"]
    #[doc = " of 1/8.  If the entire JPEG image will be decompressed, then the width and"]
    #[doc = " height of the scaled destination image can be determined by calling"]
    #[doc = " #TJSCALED() with the JPEG width and height (see #TJPARAM_JPEGWIDTH and"]
    #[doc = " #TJPARAM_JPEGHEIGHT) and the specified scaling factor.  When decompressing"]
    #[doc = " into a planar YUV image, an intermediate buffer copy will be performed if"]
    #[doc = " the width or height of the scaled destination image is not an even multiple"]
    #[doc = " of the iMCU size (see #tjMCUWidth and #tjMCUHeight.)  Note that"]
    #[doc = " decompression scaling is not available (and the specified scaling factor is"]
    #[doc = " ignored) when decompressing lossless JPEG images (see #TJPARAM_LOSSLESS),"]
    #[doc = " since the IDCT algorithm is not used with those images.  Note also that"]
    #[doc = " #TJPARAM_FASTDCT is ignored when decompression scaling is enabled."]
    #[doc = ""]
    #[doc = " @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr().)"]
    pub fn tj3SetScalingFactor(handle: tjhandle, scalingFactor: tjscalingfactor) -> libc::c_int;
}
extern "C" {
    #[doc = " Set the cropping region for partially decompressing a lossy JPEG image into"]
    #[doc = " a packed-pixel image"]
    #[doc = ""]
    #[doc = " @param handle handle to a TurboJPEG instance that has been initialized for"]
    #[doc = " decompression"]
    #[doc = ""]
    #[doc = " @param croppingRegion #tjregion structure that specifies a subregion of the"]
    #[doc = " JPEG image to decompress, or <tt>#TJUNCROPPED</tt> for no cropping.  The"]
    #[doc = " left boundary of the cropping region must be evenly divisible by the scaled"]
    #[doc = " iMCU width-- <tt>#TJSCALED(#tjMCUWidth[subsamp], scalingFactor)</tt>, where"]
    #[doc = " `subsamp` is the level of chrominance subsampling in the JPEG image (see"]
    #[doc = " #TJPARAM_SUBSAMP) and `scalingFactor` is the decompression scaling factor"]
    #[doc = " (see #tj3SetScalingFactor().)  The cropping region should be specified"]
    #[doc = " relative to the scaled image dimensions.  Unless `croppingRegion` is"]
    #[doc = " <tt>#TJUNCROPPED</tt>, the JPEG header must be read (see"]
    #[doc = " #tj3DecompressHeader()) prior to calling this function."]
    #[doc = ""]
    #[doc = " @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr().)"]
    pub fn tj3SetCroppingRegion(handle: tjhandle, croppingRegion: tjregion) -> libc::c_int;
}
extern "C" {
    #[doc = " Decompress a JPEG image with 2 to 8 bits of data precision per sample into a"]
    #[doc = " packed-pixel RGB, grayscale, or CMYK image with the same data precision."]
    #[doc = " The @ref TJPARAM \"parameters\" that describe the JPEG image will be set when"]
    #[doc = " this function returns."]
    #[doc = ""]
    #[doc = " @param handle handle to a TurboJPEG instance that has been initialized for"]
    #[doc = " decompression"]
    #[doc = ""]
    #[doc = " @param jpegBuf pointer to a byte buffer containing the JPEG image to"]
    #[doc = " decompress"]
    #[doc = ""]
    #[doc = " @param jpegSize size of the JPEG image (in bytes)"]
    #[doc = ""]
    #[doc = " @param dstBuf pointer to a buffer that will receive the packed-pixel"]
    #[doc = " decompressed image.  This buffer should normally be"]
    #[doc = " `pitch * destinationHeight` samples in size.  However, you can also use this"]
    #[doc = " parameter to decompress into a specific region of a larger buffer.  NOTE:"]
    #[doc = " If the JPEG image is lossy, then `destinationHeight` is either the scaled"]
    #[doc = " JPEG height (see #TJSCALED(), #TJPARAM_JPEGHEIGHT, and"]
    #[doc = " #tj3SetScalingFactor()) or the height of the cropping region (see"]
    #[doc = " #tj3SetCroppingRegion().)  If the JPEG image is lossless, then"]
    #[doc = " `destinationHeight` is the JPEG height."]
    #[doc = ""]
    #[doc = " @param pitch samples per row in the destination image.  Normally this should"]
    #[doc = " be set to <tt>destinationWidth * #tjPixelSize[pixelFormat]</tt>, if the"]
    #[doc = " destination image should be unpadded.  (Setting this parameter to 0 is the"]
    #[doc = " equivalent of setting it to"]
    #[doc = " <tt>destinationWidth * #tjPixelSize[pixelFormat]</tt>.)  However, you can"]
    #[doc = " also use this parameter to specify the row alignment/padding of the"]
    #[doc = " destination image, to skip rows, or to decompress into a specific region of"]
    #[doc = " a larger buffer.  NOTE: If the JPEG image is lossy, then `destinationWidth`"]
    #[doc = " is either the scaled JPEG width (see #TJSCALED(), #TJPARAM_JPEGWIDTH, and"]
    #[doc = " #tj3SetScalingFactor()) or the width of the cropping region (see"]
    #[doc = " #tj3SetCroppingRegion().)  If the JPEG image is lossless, then"]
    #[doc = " `destinationWidth` is the JPEG width."]
    #[doc = ""]
    #[doc = " @param pixelFormat pixel format of the destination image (see @ref"]
    #[doc = " TJPF \"Pixel formats\".)"]
    #[doc = ""]
    #[doc = " @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()"]
    #[doc = " and #tj3GetErrorCode().)"]
    pub fn tj3Decompress8(
        handle: tjhandle,
        jpegBuf: *const libc::c_uchar,
        jpegSize: size_t,
        dstBuf: *mut libc::c_uchar,
        pitch: libc::c_int,
        pixelFormat: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Decompress a JPEG image with 9 to 12 bits of data precision per sample into"]
    #[doc = " a packed-pixel RGB, grayscale, or CMYK image with the same data precision."]
    #[doc = ""]
    #[doc = " \\details \\copydetails tj3Decompress8()"]
    pub fn tj3Decompress12(
        handle: tjhandle,
        jpegBuf: *const libc::c_uchar,
        jpegSize: size_t,
        dstBuf: *mut libc::c_short,
        pitch: libc::c_int,
        pixelFormat: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Decompress a lossless JPEG image with 13 to 16 bits of data precision per"]
    #[doc = " sample into a packed-pixel RGB, grayscale, or CMYK image with the same"]
    #[doc = " data precision."]
    #[doc = ""]
    #[doc = " \\details \\copydetails tj3Decompress8()"]
    pub fn tj3Decompress16(
        handle: tjhandle,
        jpegBuf: *const libc::c_uchar,
        jpegSize: size_t,
        dstBuf: *mut libc::c_ushort,
        pitch: libc::c_int,
        pixelFormat: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Decompress an 8-bit-per-sample JPEG image into separate 8-bit-per-sample Y,"]
    #[doc = " U (Cb), and V (Cr) image planes.  This function performs JPEG decompression"]
    #[doc = " but leaves out the color conversion step, so a planar YUV image is generated"]
    #[doc = " instead of a packed-pixel image.  The @ref TJPARAM \"parameters\" that"]
    #[doc = " describe the JPEG image will be set when this function returns."]
    #[doc = ""]
    #[doc = " @param handle handle to a TurboJPEG instance that has been initialized for"]
    #[doc = " decompression"]
    #[doc = ""]
    #[doc = " @param jpegBuf pointer to a byte buffer containing the JPEG image to"]
    #[doc = " decompress"]
    #[doc = ""]
    #[doc = " @param jpegSize size of the JPEG image (in bytes)"]
    #[doc = ""]
    #[doc = " @param dstPlanes an array of pointers to Y, U (Cb), and V (Cr) image planes"]
    #[doc = " (or just a Y plane, if decompressing a grayscale image) that will receive"]
    #[doc = " the decompressed image.  These planes can be contiguous or non-contiguous in"]
    #[doc = " memory.  Use #tj3YUVPlaneSize() to determine the appropriate size for each"]
    #[doc = " plane based on the scaled JPEG width and height (see #TJSCALED(),"]
    #[doc = " #TJPARAM_JPEGWIDTH, #TJPARAM_JPEGHEIGHT, and #tj3SetScalingFactor()),"]
    #[doc = " strides, and level of chrominance subsampling (see #TJPARAM_SUBSAMP.)  Refer"]
    #[doc = " to @ref YUVnotes \"YUV Image Format Notes\" for more details."]
    #[doc = ""]
    #[doc = " @param strides an array of integers, each specifying the number of bytes per"]
    #[doc = " row in the corresponding plane of the YUV image.  Setting the stride for any"]
    #[doc = " plane to 0 is the same as setting it to the scaled plane width (see"]
    #[doc = " @ref YUVnotes \"YUV Image Format Notes\".)  If `strides` is NULL, then the"]
    #[doc = " strides for all planes will be set to their respective scaled plane widths."]
    #[doc = " You can adjust the strides in order to add an arbitrary amount of row"]
    #[doc = " padding to each plane or to decompress the JPEG image into a subregion of a"]
    #[doc = " larger planar YUV image."]
    #[doc = ""]
    #[doc = " @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()"]
    #[doc = " and #tj3GetErrorCode().)"]
    pub fn tj3DecompressToYUVPlanes8(
        handle: tjhandle,
        jpegBuf: *const libc::c_uchar,
        jpegSize: size_t,
        dstPlanes: *mut *mut libc::c_uchar,
        strides: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Decompress an 8-bit-per-sample JPEG image into an 8-bit-per-sample unified"]
    #[doc = " planar YUV image.  This function performs JPEG decompression but leaves out"]
    #[doc = " the color conversion step, so a planar YUV image is generated instead of a"]
    #[doc = " packed-pixel image.  The @ref TJPARAM \"parameters\" that describe the JPEG"]
    #[doc = " image will be set when this function returns."]
    #[doc = ""]
    #[doc = " @param handle handle to a TurboJPEG instance that has been initialized for"]
    #[doc = " decompression"]
    #[doc = ""]
    #[doc = " @param jpegBuf pointer to a byte buffer containing the JPEG image to"]
    #[doc = " decompress"]
    #[doc = ""]
    #[doc = " @param jpegSize size of the JPEG image (in bytes)"]
    #[doc = ""]
    #[doc = " @param dstBuf pointer to a buffer that will receive the unified planar YUV"]
    #[doc = " decompressed image.  Use #tj3YUVBufSize() to determine the appropriate size"]
    #[doc = " for this buffer based on the scaled JPEG width and height (see #TJSCALED(),"]
    #[doc = " #TJPARAM_JPEGWIDTH, #TJPARAM_JPEGHEIGHT, and #tj3SetScalingFactor()), row"]
    #[doc = " alignment, and level of chrominance subsampling (see #TJPARAM_SUBSAMP.)  The"]
    #[doc = " Y, U (Cb), and V (Cr) image planes will be stored sequentially in the"]
    #[doc = " buffer.  (Refer to @ref YUVnotes \"YUV Image Format Notes\".)"]
    #[doc = ""]
    #[doc = " @param align row alignment (in bytes) of the YUV image (must be a power of"]
    #[doc = " 2.)  Setting this parameter to n will cause each row in each plane of the"]
    #[doc = " YUV image to be padded to the nearest multiple of n bytes (1 = unpadded.)"]
    #[doc = " To generate images suitable for X Video, `align` should be set to 4."]
    #[doc = ""]
    #[doc = " @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()"]
    #[doc = " and #tj3GetErrorCode().)"]
    pub fn tj3DecompressToYUV8(
        handle: tjhandle,
        jpegBuf: *const libc::c_uchar,
        jpegSize: size_t,
        dstBuf: *mut libc::c_uchar,
        align: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Decode a set of 8-bit-per-sample Y, U (Cb), and V (Cr) image planes into an"]
    #[doc = " 8-bit-per-sample packed-pixel RGB or grayscale image.  This function"]
    #[doc = " performs color conversion (which is accelerated in the libjpeg-turbo"]
    #[doc = " implementation) but does not execute any of the other steps in the JPEG"]
    #[doc = " decompression process."]
    #[doc = ""]
    #[doc = " @param handle handle to a TurboJPEG instance that has been initialized for"]
    #[doc = " decompression"]
    #[doc = ""]
    #[doc = " @param srcPlanes an array of pointers to Y, U (Cb), and V (Cr) image planes"]
    #[doc = " (or just a Y plane, if decoding a grayscale image) that contain a YUV image"]
    #[doc = " to be decoded.  These planes can be contiguous or non-contiguous in memory."]
    #[doc = " The size of each plane should match the value returned by #tj3YUVPlaneSize()"]
    #[doc = " for the given image width, height, strides, and level of chrominance"]
    #[doc = " subsampling (see #TJPARAM_SUBSAMP.)  Refer to @ref YUVnotes"]
    #[doc = " \"YUV Image Format Notes\" for more details."]
    #[doc = ""]
    #[doc = " @param strides an array of integers, each specifying the number of bytes per"]
    #[doc = " row in the corresponding plane of the YUV source image.  Setting the stride"]
    #[doc = " for any plane to 0 is the same as setting it to the plane width (see"]
    #[doc = " @ref YUVnotes \"YUV Image Format Notes\".)  If `strides` is NULL, then the"]
    #[doc = " strides for all planes will be set to their respective plane widths.  You"]
    #[doc = " can adjust the strides in order to specify an arbitrary amount of row"]
    #[doc = " padding in each plane or to decode a subregion of a larger planar YUV image."]
    #[doc = ""]
    #[doc = " @param dstBuf pointer to a buffer that will receive the packed-pixel decoded"]
    #[doc = " image.  This buffer should normally be `pitch * height` bytes in size."]
    #[doc = " However, you can also use this parameter to decode into a specific region of"]
    #[doc = " a larger buffer."]
    #[doc = ""]
    #[doc = " @param width width (in pixels) of the source and destination images"]
    #[doc = ""]
    #[doc = " @param pitch bytes per row in the destination image.  Normally this should"]
    #[doc = " be set to <tt>width * #tjPixelSize[pixelFormat]</tt>, if the destination"]
    #[doc = " image should be unpadded.  (Setting this parameter to 0 is the equivalent of"]
    #[doc = " setting it to <tt>width * #tjPixelSize[pixelFormat]</tt>.)  However, you can"]
    #[doc = " also use this parameter to specify the row alignment/padding of the"]
    #[doc = " destination image, to skip rows, or to decode into a specific region of a"]
    #[doc = " larger buffer."]
    #[doc = ""]
    #[doc = " @param height height (in pixels) of the source and destination images"]
    #[doc = ""]
    #[doc = " @param pixelFormat pixel format of the destination image (see @ref TJPF"]
    #[doc = " \"Pixel formats\".)"]
    #[doc = ""]
    #[doc = " @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()"]
    #[doc = " and #tj3GetErrorCode().)"]
    pub fn tj3DecodeYUVPlanes8(
        handle: tjhandle,
        srcPlanes: *const *const libc::c_uchar,
        strides: *const libc::c_int,
        dstBuf: *mut libc::c_uchar,
        width: libc::c_int,
        pitch: libc::c_int,
        height: libc::c_int,
        pixelFormat: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Decode an 8-bit-per-sample unified planar YUV image into an 8-bit-per-sample"]
    #[doc = " packed-pixel RGB or grayscale image.  This function performs color"]
    #[doc = " conversion (which is accelerated in the libjpeg-turbo implementation) but"]
    #[doc = " does not execute any of the other steps in the JPEG decompression process."]
    #[doc = ""]
    #[doc = " @param handle handle to a TurboJPEG instance that has been initialized for"]
    #[doc = " decompression"]
    #[doc = ""]
    #[doc = " @param srcBuf pointer to a buffer containing a unified planar YUV source"]
    #[doc = " image to be decoded.  The size of this buffer should match the value"]
    #[doc = " returned by #tj3YUVBufSize() for the given image width, height, row"]
    #[doc = " alignment, and level of chrominance subsampling (see #TJPARAM_SUBSAMP.)  The"]
    #[doc = " Y, U (Cb), and V (Cr) image planes should be stored sequentially in the"]
    #[doc = " source buffer.  (Refer to @ref YUVnotes \"YUV Image Format Notes\".)"]
    #[doc = ""]
    #[doc = " @param align row alignment (in bytes) of the YUV source image (must be a"]
    #[doc = " power of 2.)  Setting this parameter to n indicates that each row in each"]
    #[doc = " plane of the YUV source image is padded to the nearest multiple of n bytes"]
    #[doc = " (1 = unpadded.)"]
    #[doc = ""]
    #[doc = " @param dstBuf pointer to a buffer that will receive the packed-pixel decoded"]
    #[doc = " image.  This buffer should normally be `pitch * height` bytes in size."]
    #[doc = " However, you can also use this parameter to decode into a specific region of"]
    #[doc = " a larger buffer."]
    #[doc = ""]
    #[doc = " @param width width (in pixels) of the source and destination images"]
    #[doc = ""]
    #[doc = " @param pitch bytes per row in the destination image.  Normally this should"]
    #[doc = " be set to <tt>width * #tjPixelSize[pixelFormat]</tt>, if the destination"]
    #[doc = " image should be unpadded.  (Setting this parameter to 0 is the equivalent of"]
    #[doc = " setting it to <tt>width * #tjPixelSize[pixelFormat]</tt>.)  However, you can"]
    #[doc = " also use this parameter to specify the row alignment/padding of the"]
    #[doc = " destination image, to skip rows, or to decode into a specific region of a"]
    #[doc = " larger buffer."]
    #[doc = ""]
    #[doc = " @param height height (in pixels) of the source and destination images"]
    #[doc = ""]
    #[doc = " @param pixelFormat pixel format of the destination image (see @ref TJPF"]
    #[doc = " \"Pixel formats\".)"]
    #[doc = ""]
    #[doc = " @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()"]
    #[doc = " and #tj3GetErrorCode().)"]
    pub fn tj3DecodeYUV8(
        handle: tjhandle,
        srcBuf: *const libc::c_uchar,
        align: libc::c_int,
        dstBuf: *mut libc::c_uchar,
        width: libc::c_int,
        pitch: libc::c_int,
        height: libc::c_int,
        pixelFormat: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " The maximum size of the buffer (in bytes) required to hold a JPEG image"]
    #[doc = " transformed with the given transform parameters and/or cropping region."]
    #[doc = " This function is a wrapper for #tj3JPEGBufSize() that takes into account"]
    #[doc = " cropping, transposition of the width and height (which affects the"]
    #[doc = " destination image dimensions and level of chrominance subsampling),"]
    #[doc = " grayscale conversion, and the ICC profile (if any) that was previously"]
    #[doc = " associated with the TurboJPEG instance (see #tj3SetICCProfile()) or"]
    #[doc = " extracted from the source image (see #tj3GetICCProfile() and"]
    #[doc = " #TJPARAM_SAVEMARKERS.)  The JPEG header must be read (see"]
    #[doc = " tj3DecompressHeader()) prior to calling this function."]
    #[doc = ""]
    #[doc = " @param handle handle to a TurboJPEG instance that has been initialized for"]
    #[doc = " lossless transformation"]
    #[doc = ""]
    #[doc = " @param transform pointer to a #tjtransform structure that specifies the"]
    #[doc = " transform parameters and/or cropping region for the JPEG image."]
    #[doc = ""]
    #[doc = " @return the maximum size of the buffer (in bytes) required to hold the"]
    #[doc = " transformed image, or 0 if an error occurred (see #tj3GetErrorStr() and"]
    #[doc = " #tj3GetErrorCode().)"]
    pub fn tj3TransformBufSize(handle: tjhandle, transform: *const tjtransform) -> size_t;
}
extern "C" {
    #[doc = " Losslessly transform a JPEG image into another JPEG image.  Lossless"]
    #[doc = " transforms work by moving the raw DCT coefficients from one JPEG image"]
    #[doc = " structure to another without altering the values of the coefficients.  While"]
    #[doc = " this is typically faster than decompressing the image, transforming it, and"]
    #[doc = " re-compressing it, lossless transforms are not free.  Each lossless"]
    #[doc = " transform requires reading and performing entropy decoding on all of the"]
    #[doc = " coefficients in the source image, regardless of the size of the destination"]
    #[doc = " image.  Thus, this function provides a means of generating multiple"]
    #[doc = " transformed images from the same source or applying multiple transformations"]
    #[doc = " simultaneously, in order to eliminate the need to read the source"]
    #[doc = " coefficients multiple times."]
    #[doc = ""]
    #[doc = " @param handle handle to a TurboJPEG instance that has been initialized for"]
    #[doc = " lossless transformation"]
    #[doc = ""]
    #[doc = " @param jpegBuf pointer to a byte buffer containing the JPEG source image to"]
    #[doc = " transform"]
    #[doc = ""]
    #[doc = " @param jpegSize size of the JPEG source image (in bytes)"]
    #[doc = ""]
    #[doc = " @param n the number of transformed JPEG images to generate"]
    #[doc = ""]
    #[doc = " @param dstBufs pointer to an array of n byte buffers.  `dstBufs[i]` will"]
    #[doc = " receive a JPEG image that has been transformed using the parameters in"]
    #[doc = " `transforms[i]`.  TurboJPEG has the ability to reallocate the JPEG"]
    #[doc = " destination buffer to accommodate the size of the transformed JPEG image."]
    #[doc = " Thus, you can choose to:"]
    #[doc = " -# pre-allocate the JPEG destination buffer with an arbitrary size using"]
    #[doc = " #tj3Alloc() and let TurboJPEG grow the buffer as needed,"]
    #[doc = " -# set `dstBufs[i]` to NULL to tell TurboJPEG to allocate the buffer for"]
    #[doc = " you, or"]
    #[doc = " -# pre-allocate the buffer to a \"worst case\" size determined by calling"]
    #[doc = " #tj3TransformBufSize().  Under normal circumstances, this should ensure that"]
    #[doc = " the buffer never has to be re-allocated.  (Setting #TJPARAM_NOREALLOC"]
    #[doc = " guarantees that it won't be.)  Note, however, that there are some rare cases"]
    #[doc = " (such as transforming images with a large amount of embedded Exif data) in"]
    #[doc = " which the transformed JPEG image will be larger than the worst-case size,"]
    #[doc = " and #TJPARAM_NOREALLOC cannot be used in those cases unless the embedded"]
    #[doc = " data is discarded using #TJXOPT_COPYNONE or #TJPARAM_SAVEMARKERS."]
    #[doc = " ."]
    #[doc = " If you choose option 1 or 3, then `dstSizes[i]` should be set to the size of"]
    #[doc = " your pre-allocated buffer.  In any case, unless you have set"]
    #[doc = " #TJPARAM_NOREALLOC, you should always check `dstBufs[i]` upon return from"]
    #[doc = " this function, as it may have changed."]
    #[doc = ""]
    #[doc = " @param dstSizes pointer to an array of n size_t variables that will receive"]
    #[doc = " the actual sizes (in bytes) of each transformed JPEG image.  If `dstBufs[i]`"]
    #[doc = " points to a pre-allocated buffer, then `dstSizes[i]` should be set to the"]
    #[doc = " size of the buffer.  Upon return, `dstSizes[i]` will contain the size of the"]
    #[doc = " transformed JPEG image (in bytes.)"]
    #[doc = ""]
    #[doc = " @param transforms pointer to an array of n #tjtransform structures, each of"]
    #[doc = " which specifies the transform parameters and/or cropping region for the"]
    #[doc = " corresponding transformed JPEG image."]
    #[doc = ""]
    #[doc = " @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()"]
    #[doc = " and #tj3GetErrorCode().)"]
    pub fn tj3Transform(
        handle: tjhandle,
        jpegBuf: *const libc::c_uchar,
        jpegSize: size_t,
        n: libc::c_int,
        dstBufs: *mut *mut libc::c_uchar,
        dstSizes: *mut size_t,
        transforms: *const tjtransform,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Load a packed-pixel image with 2 to 8 bits of data precision per sample from"]
    #[doc = " disk into memory."]
    #[doc = ""]
    #[doc = " @param handle handle to a TurboJPEG instance"]
    #[doc = ""]
    #[doc = " @param filename name of a file containing a packed-pixel image in Windows"]
    #[doc = " BMP or PBMPLUS (PPM/PGM) format.  Windows BMP files require 8-bit-per-sample"]
    #[doc = " data precision.  When loading a PBMPLUS file, the target data precision"]
    #[doc = " (from 2 to 8 bits per sample) can be specified using #TJPARAM_PRECISION and"]
    #[doc = " defaults to 8 if #TJPARAM_PRECISION is unset or out of range.  If the data"]
    #[doc = " precision of the PBMPLUS file does not match the target data precision, then"]
    #[doc = " upconverting or downconverting will be performed."]
    #[doc = ""]
    #[doc = " @param width pointer to an integer variable that will receive the width (in"]
    #[doc = " pixels) of the packed-pixel image"]
    #[doc = ""]
    #[doc = " @param align row alignment (in samples) of the packed-pixel buffer to be"]
    #[doc = " returned (must be a power of 2.)  Setting this parameter to n will cause all"]
    #[doc = " rows in the buffer to be padded to the nearest multiple of n samples"]
    #[doc = " (1 = unpadded.)"]
    #[doc = ""]
    #[doc = " @param height pointer to an integer variable that will receive the height"]
    #[doc = " (in pixels) of the packed-pixel image"]
    #[doc = ""]
    #[doc = " @param pixelFormat pointer to an integer variable that specifies or will"]
    #[doc = " receive the pixel format of the packed-pixel buffer.  The behavior of this"]
    #[doc = " function varies depending on the value of `*pixelFormat` passed to the"]
    #[doc = " function:"]
    #[doc = " - @ref TJPF_UNKNOWN : The packed-pixel buffer returned by this function will"]
    #[doc = " use the most optimal pixel format for the file type, and `*pixelFormat` will"]
    #[doc = " contain the ID of that pixel format upon successful return from this"]
    #[doc = " function."]
    #[doc = " - @ref TJPF_GRAY : Only PGM files and 8-bit-per-pixel BMP files with a"]
    #[doc = " grayscale colormap can be loaded."]
    #[doc = " - @ref TJPF_CMYK : The RGB or grayscale pixels stored in the file will be"]
    #[doc = " converted using a quick & dirty algorithm that is suitable only for testing"]
    #[doc = " purposes.  (Proper conversion between CMYK and other formats requires a"]
    #[doc = " color management system.)"]
    #[doc = " - Other @ref TJPF \"pixel formats\" : The packed-pixel buffer will use the"]
    #[doc = " specified pixel format, and pixel format conversion will be performed if"]
    #[doc = " necessary."]
    #[doc = ""]
    #[doc = " @return a pointer to a newly-allocated buffer containing the packed-pixel"]
    #[doc = " image, converted to the chosen pixel format and with the chosen row"]
    #[doc = " alignment, or NULL if an error occurred (see #tj3GetErrorStr().)  This"]
    #[doc = " buffer should be freed using #tj3Free()."]
    pub fn tj3LoadImage8(
        handle: tjhandle,
        filename: *const libc::c_char,
        width: *mut libc::c_int,
        align: libc::c_int,
        height: *mut libc::c_int,
        pixelFormat: *mut libc::c_int,
    ) -> *mut libc::c_uchar;
}
extern "C" {
    #[doc = " Load a packed-pixel image with 9 to 12 bits of data precision per sample"]
    #[doc = " from disk into memory."]
    #[doc = ""]
    #[doc = " @param handle handle to a TurboJPEG instance"]
    #[doc = ""]
    #[doc = " @param filename name of a file containing a packed-pixel image in PBMPLUS"]
    #[doc = " (PPM/PGM) format.  The target data precision (from 9 to 12 bits per sample)"]
    #[doc = " can be specified using #TJPARAM_PRECISION and defaults to 12 if"]
    #[doc = " #TJPARAM_PRECISION is unset or out of range.  If the data precision of the"]
    #[doc = " PBMPLUS file does not match the target data precision, then upconverting or"]
    #[doc = " downconverting will be performed."]
    #[doc = ""]
    #[doc = " @param width pointer to an integer variable that will receive the width (in"]
    #[doc = " pixels) of the packed-pixel image"]
    #[doc = ""]
    #[doc = " @param align row alignment (in samples) of the packed-pixel buffer to be"]
    #[doc = " returned (must be a power of 2.)  Setting this parameter to n will cause all"]
    #[doc = " rows in the buffer to be padded to the nearest multiple of n samples"]
    #[doc = " (1 = unpadded.)"]
    #[doc = ""]
    #[doc = " @param height pointer to an integer variable that will receive the height"]
    #[doc = " (in pixels) of the packed-pixel image"]
    #[doc = ""]
    #[doc = " @param pixelFormat pointer to an integer variable that specifies or will"]
    #[doc = " receive the pixel format of the packed-pixel buffer.  The behavior of this"]
    #[doc = " function will vary depending on the value of `*pixelFormat` passed to the"]
    #[doc = " function:"]
    #[doc = " - @ref TJPF_UNKNOWN : The packed-pixel buffer returned by this function will"]
    #[doc = " use the most optimal pixel format for the file type, and `*pixelFormat` will"]
    #[doc = " contain the ID of that pixel format upon successful return from this"]
    #[doc = " function."]
    #[doc = " - @ref TJPF_GRAY : Only PGM files can be loaded."]
    #[doc = " - @ref TJPF_CMYK : The RGB or grayscale pixels stored in the file will be"]
    #[doc = " converted using a quick & dirty algorithm that is suitable only for testing"]
    #[doc = " purposes.  (Proper conversion between CMYK and other formats requires a"]
    #[doc = " color management system.)"]
    #[doc = " - Other @ref TJPF \"pixel formats\" : The packed-pixel buffer will use the"]
    #[doc = " specified pixel format, and pixel format conversion will be performed if"]
    #[doc = " necessary."]
    #[doc = ""]
    #[doc = " @return a pointer to a newly-allocated buffer containing the packed-pixel"]
    #[doc = " image, converted to the chosen pixel format and with the chosen row"]
    #[doc = " alignment, or NULL if an error occurred (see #tj3GetErrorStr().)  This"]
    #[doc = " buffer should be freed using #tj3Free()."]
    pub fn tj3LoadImage12(
        handle: tjhandle,
        filename: *const libc::c_char,
        width: *mut libc::c_int,
        align: libc::c_int,
        height: *mut libc::c_int,
        pixelFormat: *mut libc::c_int,
    ) -> *mut libc::c_short;
}
extern "C" {
    #[doc = " Load a packed-pixel image with 13 to 16 bits of data precision per sample"]
    #[doc = " from disk into memory."]
    #[doc = ""]
    #[doc = " @param handle handle to a TurboJPEG instance"]
    #[doc = ""]
    #[doc = " @param filename name of a file containing a packed-pixel image in PBMPLUS"]
    #[doc = " (PPM/PGM) format.  The target data precision (from 13 to 16 bits per sample)"]
    #[doc = " can be specified using #TJPARAM_PRECISION and defaults to 16 if"]
    #[doc = " #TJPARAM_PRECISION is unset or out of range.  If the data precision of the"]
    #[doc = " PBMPLUS file does not match the target data precision, then upconverting or"]
    #[doc = " downconverting will be performed."]
    #[doc = ""]
    #[doc = " @param width pointer to an integer variable that will receive the width (in"]
    #[doc = " pixels) of the packed-pixel image"]
    #[doc = ""]
    #[doc = " @param align row alignment (in samples) of the packed-pixel buffer to be"]
    #[doc = " returned (must be a power of 2.)  Setting this parameter to n will cause all"]
    #[doc = " rows in the buffer to be padded to the nearest multiple of n samples"]
    #[doc = " (1 = unpadded.)"]
    #[doc = ""]
    #[doc = " @param height pointer to an integer variable that will receive the height"]
    #[doc = " (in pixels) of the packed-pixel image"]
    #[doc = ""]
    #[doc = " @param pixelFormat pointer to an integer variable that specifies or will"]
    #[doc = " receive the pixel format of the packed-pixel buffer.  The behavior of this"]
    #[doc = " function will vary depending on the value of `*pixelFormat` passed to the"]
    #[doc = " function:"]
    #[doc = " - @ref TJPF_UNKNOWN : The packed-pixel buffer returned by this function will"]
    #[doc = " use the most optimal pixel format for the file type, and `*pixelFormat` will"]
    #[doc = " contain the ID of that pixel format upon successful return from this"]
    #[doc = " function."]
    #[doc = " - @ref TJPF_GRAY : Only PGM files can be loaded."]
    #[doc = " - @ref TJPF_CMYK : The RGB or grayscale pixels stored in the file will be"]
    #[doc = " converted using a quick & dirty algorithm that is suitable only for testing"]
    #[doc = " purposes.  (Proper conversion between CMYK and other formats requires a"]
    #[doc = " color management system.)"]
    #[doc = " - Other @ref TJPF \"pixel formats\" : The packed-pixel buffer will use the"]
    #[doc = " specified pixel format, and pixel format conversion will be performed if"]
    #[doc = " necessary."]
    #[doc = ""]
    #[doc = " @return a pointer to a newly-allocated buffer containing the packed-pixel"]
    #[doc = " image, converted to the chosen pixel format and with the chosen row"]
    #[doc = " alignment, or NULL if an error occurred (see #tj3GetErrorStr().)  This"]
    #[doc = " buffer should be freed using #tj3Free()."]
    pub fn tj3LoadImage16(
        handle: tjhandle,
        filename: *const libc::c_char,
        width: *mut libc::c_int,
        align: libc::c_int,
        height: *mut libc::c_int,
        pixelFormat: *mut libc::c_int,
    ) -> *mut libc::c_ushort;
}
extern "C" {
    #[doc = " Save a packed-pixel image with 2 to 8 bits of data precision per sample from"]
    #[doc = " memory to disk."]
    #[doc = ""]
    #[doc = " @param handle handle to a TurboJPEG instance"]
    #[doc = ""]
    #[doc = " @param filename name of a file to which to save the packed-pixel image.  The"]
    #[doc = " image will be stored in Windows BMP or PBMPLUS (PPM/PGM) format, depending"]
    #[doc = " on the file extension.  Windows BMP files require 8-bit-per-sample data"]
    #[doc = " precision.  When saving a PBMPLUS file, the source data precision (from 2 to"]
    #[doc = " 8 bits per sample) can be specified using #TJPARAM_PRECISION and defaults to"]
    #[doc = " 8 if #TJPARAM_PRECISION is unset or out of range."]
    #[doc = ""]
    #[doc = " @param buffer pointer to a buffer containing a packed-pixel RGB, grayscale,"]
    #[doc = " or CMYK image to be saved"]
    #[doc = ""]
    #[doc = " @param width width (in pixels) of the packed-pixel image"]
    #[doc = ""]
    #[doc = " @param pitch samples per row in the packed-pixel image.  Setting this"]
    #[doc = " parameter to 0 is the equivalent of setting it to"]
    #[doc = " <tt>width * #tjPixelSize[pixelFormat]</tt>."]
    #[doc = ""]
    #[doc = " @param height height (in pixels) of the packed-pixel image"]
    #[doc = ""]
    #[doc = " @param pixelFormat pixel format of the packed-pixel image (see @ref TJPF"]
    #[doc = " \"Pixel formats\".)  If this parameter is set to @ref TJPF_GRAY, then the"]
    #[doc = " image will be stored in PGM or 8-bit-per-pixel (indexed color) BMP format."]
    #[doc = " Otherwise, the image will be stored in PPM or 24-bit-per-pixel BMP format."]
    #[doc = " If this parameter is set to @ref TJPF_CMYK, then the CMYK pixels will be"]
    #[doc = " converted to RGB using a quick & dirty algorithm that is suitable only for"]
    #[doc = " testing purposes.  (Proper conversion between CMYK and other formats"]
    #[doc = " requires a color management system.)"]
    #[doc = ""]
    #[doc = " @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr().)"]
    pub fn tj3SaveImage8(
        handle: tjhandle,
        filename: *const libc::c_char,
        buffer: *const libc::c_uchar,
        width: libc::c_int,
        pitch: libc::c_int,
        height: libc::c_int,
        pixelFormat: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Save a packed-pixel image with 9 to 12 bits of data precision per sample"]
    #[doc = " from memory to disk."]
    #[doc = ""]
    #[doc = " @param handle handle to a TurboJPEG instance"]
    #[doc = ""]
    #[doc = " @param filename name of a file to which to save the packed-pixel image,"]
    #[doc = " which will be stored in PBMPLUS (PPM/PGM) format.  The source data precision"]
    #[doc = " (from 9 to 12 bits per sample) can be specified using #TJPARAM_PRECISION and"]
    #[doc = " defaults to 12 if #TJPARAM_PRECISION is unset or out of range."]
    #[doc = ""]
    #[doc = " @param buffer pointer to a buffer containing a packed-pixel RGB, grayscale,"]
    #[doc = " or CMYK image to be saved"]
    #[doc = ""]
    #[doc = " @param width width (in pixels) of the packed-pixel image"]
    #[doc = ""]
    #[doc = " @param pitch samples per row in the packed-pixel image.  Setting this"]
    #[doc = " parameter to 0 is the equivalent of setting it to"]
    #[doc = " <tt>width * #tjPixelSize[pixelFormat]</tt>."]
    #[doc = ""]
    #[doc = " @param height height (in pixels) of the packed-pixel image"]
    #[doc = ""]
    #[doc = " @param pixelFormat pixel format of the packed-pixel image (see @ref TJPF"]
    #[doc = " \"Pixel formats\".)  If this parameter is set to @ref TJPF_GRAY, then the"]
    #[doc = " image will be stored in PGM format.  Otherwise, the image will be stored in"]
    #[doc = " PPM format.  If this parameter is set to @ref TJPF_CMYK, then the CMYK"]
    #[doc = " pixels will be converted to RGB using a quick & dirty algorithm that is"]
    #[doc = " suitable only for testing purposes.  (Proper conversion between CMYK and"]
    #[doc = " other formats requires a color management system.)"]
    #[doc = ""]
    #[doc = " @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr().)"]
    pub fn tj3SaveImage12(
        handle: tjhandle,
        filename: *const libc::c_char,
        buffer: *const libc::c_short,
        width: libc::c_int,
        pitch: libc::c_int,
        height: libc::c_int,
        pixelFormat: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Save a packed-pixel image with 13 to 16 bits of data precision per sample"]
    #[doc = " from memory to disk."]
    #[doc = ""]
    #[doc = " @param handle handle to a TurboJPEG instance"]
    #[doc = ""]
    #[doc = " @param filename name of a file to which to save the packed-pixel image,"]
    #[doc = " which will be stored in PBMPLUS (PPM/PGM) format.  The source data precision"]
    #[doc = " (from 13 to 16 bits per sample) can be specified using #TJPARAM_PRECISION"]
    #[doc = " and defaults to 16 if #TJPARAM_PRECISION is unset or out of range."]
    #[doc = ""]
    #[doc = " @param buffer pointer to a buffer containing a packed-pixel RGB, grayscale,"]
    #[doc = " or CMYK image to be saved"]
    #[doc = ""]
    #[doc = " @param width width (in pixels) of the packed-pixel image"]
    #[doc = ""]
    #[doc = " @param pitch samples per row in the packed-pixel image.  Setting this"]
    #[doc = " parameter to 0 is the equivalent of setting it to"]
    #[doc = " <tt>width * #tjPixelSize[pixelFormat]</tt>."]
    #[doc = ""]
    #[doc = " @param height height (in pixels) of the packed-pixel image"]
    #[doc = ""]
    #[doc = " @param pixelFormat pixel format of the packed-pixel image (see @ref TJPF"]
    #[doc = " \"Pixel formats\".)  If this parameter is set to @ref TJPF_GRAY, then the"]
    #[doc = " image will be stored in PGM format.  Otherwise, the image will be stored in"]
    #[doc = " PPM format.  If this parameter is set to @ref TJPF_CMYK, then the CMYK"]
    #[doc = " pixels will be converted to RGB using a quick & dirty algorithm that is"]
    #[doc = " suitable only for testing purposes.  (Proper conversion between CMYK and"]
    #[doc = " other formats requires a color management system.)"]
    #[doc = ""]
    #[doc = " @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr().)"]
    pub fn tj3SaveImage16(
        handle: tjhandle,
        filename: *const libc::c_char,
        buffer: *const libc::c_ushort,
        width: libc::c_int,
        pitch: libc::c_int,
        height: libc::c_int,
        pixelFormat: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn TJBUFSIZE(width: libc::c_int, height: libc::c_int) -> libc::c_ulong;
}
extern "C" {
    pub fn tjCompress(
        handle: tjhandle,
        srcBuf: *mut libc::c_uchar,
        width: libc::c_int,
        pitch: libc::c_int,
        height: libc::c_int,
        pixelSize: libc::c_int,
        dstBuf: *mut libc::c_uchar,
        compressedSize: *mut libc::c_ulong,
        jpegSubsamp: libc::c_int,
        jpegQual: libc::c_int,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn tjDecompress(
        handle: tjhandle,
        jpegBuf: *mut libc::c_uchar,
        jpegSize: libc::c_ulong,
        dstBuf: *mut libc::c_uchar,
        width: libc::c_int,
        pitch: libc::c_int,
        height: libc::c_int,
        pixelSize: libc::c_int,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn tjDecompressHeader(
        handle: tjhandle,
        jpegBuf: *mut libc::c_uchar,
        jpegSize: libc::c_ulong,
        width: *mut libc::c_int,
        height: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn tjDestroy(handle: tjhandle) -> libc::c_int;
}
extern "C" {
    pub fn tjGetErrorStr() -> *mut libc::c_char;
}
extern "C" {
    pub fn tjInitCompress() -> tjhandle;
}
extern "C" {
    pub fn tjInitDecompress() -> tjhandle;
}
extern "C" {
    pub fn TJBUFSIZEYUV(
        width: libc::c_int,
        height: libc::c_int,
        jpegSubsamp: libc::c_int,
    ) -> libc::c_ulong;
}
extern "C" {
    pub fn tjDecompressHeader2(
        handle: tjhandle,
        jpegBuf: *mut libc::c_uchar,
        jpegSize: libc::c_ulong,
        width: *mut libc::c_int,
        height: *mut libc::c_int,
        jpegSubsamp: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn tjDecompressToYUV(
        handle: tjhandle,
        jpegBuf: *mut libc::c_uchar,
        jpegSize: libc::c_ulong,
        dstBuf: *mut libc::c_uchar,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn tjEncodeYUV(
        handle: tjhandle,
        srcBuf: *mut libc::c_uchar,
        width: libc::c_int,
        pitch: libc::c_int,
        height: libc::c_int,
        pixelSize: libc::c_int,
        dstBuf: *mut libc::c_uchar,
        subsamp: libc::c_int,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn tjAlloc(bytes: libc::c_int) -> *mut libc::c_uchar;
}
extern "C" {
    pub fn tjBufSize(
        width: libc::c_int,
        height: libc::c_int,
        jpegSubsamp: libc::c_int,
    ) -> libc::c_ulong;
}
extern "C" {
    pub fn tjBufSizeYUV(
        width: libc::c_int,
        height: libc::c_int,
        subsamp: libc::c_int,
    ) -> libc::c_ulong;
}
extern "C" {
    pub fn tjCompress2(
        handle: tjhandle,
        srcBuf: *const libc::c_uchar,
        width: libc::c_int,
        pitch: libc::c_int,
        height: libc::c_int,
        pixelFormat: libc::c_int,
        jpegBuf: *mut *mut libc::c_uchar,
        jpegSize: *mut libc::c_ulong,
        jpegSubsamp: libc::c_int,
        jpegQual: libc::c_int,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn tjDecompress2(
        handle: tjhandle,
        jpegBuf: *const libc::c_uchar,
        jpegSize: libc::c_ulong,
        dstBuf: *mut libc::c_uchar,
        width: libc::c_int,
        pitch: libc::c_int,
        height: libc::c_int,
        pixelFormat: libc::c_int,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn tjEncodeYUV2(
        handle: tjhandle,
        srcBuf: *mut libc::c_uchar,
        width: libc::c_int,
        pitch: libc::c_int,
        height: libc::c_int,
        pixelFormat: libc::c_int,
        dstBuf: *mut libc::c_uchar,
        subsamp: libc::c_int,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn tjFree(buffer: *mut libc::c_uchar);
}
extern "C" {
    pub fn tjGetScalingFactors(numscalingfactors: *mut libc::c_int) -> *mut tjscalingfactor;
}
extern "C" {
    pub fn tjInitTransform() -> tjhandle;
}
extern "C" {
    pub fn tjTransform(
        handle: tjhandle,
        jpegBuf: *const libc::c_uchar,
        jpegSize: libc::c_ulong,
        n: libc::c_int,
        dstBufs: *mut *mut libc::c_uchar,
        dstSizes: *mut libc::c_ulong,
        transforms: *mut tjtransform,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn tjBufSizeYUV2(
        width: libc::c_int,
        align: libc::c_int,
        height: libc::c_int,
        subsamp: libc::c_int,
    ) -> libc::c_ulong;
}
extern "C" {
    pub fn tjCompressFromYUV(
        handle: tjhandle,
        srcBuf: *const libc::c_uchar,
        width: libc::c_int,
        align: libc::c_int,
        height: libc::c_int,
        subsamp: libc::c_int,
        jpegBuf: *mut *mut libc::c_uchar,
        jpegSize: *mut libc::c_ulong,
        jpegQual: libc::c_int,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn tjCompressFromYUVPlanes(
        handle: tjhandle,
        srcPlanes: *mut *const libc::c_uchar,
        width: libc::c_int,
        strides: *const libc::c_int,
        height: libc::c_int,
        subsamp: libc::c_int,
        jpegBuf: *mut *mut libc::c_uchar,
        jpegSize: *mut libc::c_ulong,
        jpegQual: libc::c_int,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn tjDecodeYUV(
        handle: tjhandle,
        srcBuf: *const libc::c_uchar,
        align: libc::c_int,
        subsamp: libc::c_int,
        dstBuf: *mut libc::c_uchar,
        width: libc::c_int,
        pitch: libc::c_int,
        height: libc::c_int,
        pixelFormat: libc::c_int,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn tjDecodeYUVPlanes(
        handle: tjhandle,
        srcPlanes: *mut *const libc::c_uchar,
        strides: *const libc::c_int,
        subsamp: libc::c_int,
        dstBuf: *mut libc::c_uchar,
        width: libc::c_int,
        pitch: libc::c_int,
        height: libc::c_int,
        pixelFormat: libc::c_int,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn tjDecompressHeader3(
        handle: tjhandle,
        jpegBuf: *const libc::c_uchar,
        jpegSize: libc::c_ulong,
        width: *mut libc::c_int,
        height: *mut libc::c_int,
        jpegSubsamp: *mut libc::c_int,
        jpegColorspace: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn tjDecompressToYUV2(
        handle: tjhandle,
        jpegBuf: *const libc::c_uchar,
        jpegSize: libc::c_ulong,
        dstBuf: *mut libc::c_uchar,
        width: libc::c_int,
        align: libc::c_int,
        height: libc::c_int,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn tjDecompressToYUVPlanes(
        handle: tjhandle,
        jpegBuf: *const libc::c_uchar,
        jpegSize: libc::c_ulong,
        dstPlanes: *mut *mut libc::c_uchar,
        width: libc::c_int,
        strides: *mut libc::c_int,
        height: libc::c_int,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn tjEncodeYUV3(
        handle: tjhandle,
        srcBuf: *const libc::c_uchar,
        width: libc::c_int,
        pitch: libc::c_int,
        height: libc::c_int,
        pixelFormat: libc::c_int,
        dstBuf: *mut libc::c_uchar,
        align: libc::c_int,
        subsamp: libc::c_int,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn tjEncodeYUVPlanes(
        handle: tjhandle,
        srcBuf: *const libc::c_uchar,
        width: libc::c_int,
        pitch: libc::c_int,
        height: libc::c_int,
        pixelFormat: libc::c_int,
        dstPlanes: *mut *mut libc::c_uchar,
        strides: *mut libc::c_int,
        subsamp: libc::c_int,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn tjPlaneHeight(
        componentID: libc::c_int,
        height: libc::c_int,
        subsamp: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn tjPlaneSizeYUV(
        componentID: libc::c_int,
        width: libc::c_int,
        stride: libc::c_int,
        height: libc::c_int,
        subsamp: libc::c_int,
    ) -> libc::c_ulong;
}
extern "C" {
    pub fn tjPlaneWidth(
        componentID: libc::c_int,
        width: libc::c_int,
        subsamp: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn tjGetErrorCode(handle: tjhandle) -> libc::c_int;
}
extern "C" {
    pub fn tjGetErrorStr2(handle: tjhandle) -> *mut libc::c_char;
}
extern "C" {
    pub fn tjLoadImage(
        filename: *const libc::c_char,
        width: *mut libc::c_int,
        align: libc::c_int,
        height: *mut libc::c_int,
        pixelFormat: *mut libc::c_int,
        flags: libc::c_int,
    ) -> *mut libc::c_uchar;
}
extern "C" {
    pub fn tjSaveImage(
        filename: *const libc::c_char,
        buffer: *mut libc::c_uchar,
        width: libc::c_int,
        pitch: libc::c_int,
        height: libc::c_int,
        pixelFormat: libc::c_int,
        flags: libc::c_int,
    ) -> libc::c_int;
}
